

==================================================
File: jukit_config.json
==================================================

{}


==================================================
File: lazy-lock.json
==================================================

{
  "Comment.nvim": { "branch": "master", "commit": "e30b7f2008e52442154b66f7c519bfd2f1e32acb" },
  "LuaSnip": { "branch": "master", "commit": "03c8e67eb7293c404845b3982db895d59c0d1538" },
  "clipboard-image.nvim": { "branch": "main", "commit": "4ab6f7f1fa4ea97866c0e0f6160f6a36ef174438" },
  "cmp-buffer": { "branch": "main", "commit": "3022dbc9166796b644a841a02de8dd1cc1d311fa" },
  "cmp-cmdline": { "branch": "main", "commit": "d250c63aa13ead745e3a40f61fdd3470efde3923" },
  "cmp-nvim-lsp": { "branch": "main", "commit": "99290b3ec1322070bcfb9e846450a46f6efa50f0" },
  "cmp-omni": { "branch": "main", "commit": "4ef610bbd85a5ee4e97e09450c0daecbdc60de86" },
  "cmp-path": { "branch": "main", "commit": "91ff86cd9c29299a64f968ebb45846c485725f23" },
  "cmp_luasnip": { "branch": "master", "commit": "98d9cb5c2c38532bd9bdb481067b20fea8f32e90" },
  "csv.vim": { "branch": "master", "commit": "b8eb7f67babce96168e7f6b93b2ba8328b72a390" },
  "flexoki": { "branch": "main", "commit": "9d382019eaa4fe8484d7a6ebde5b3890b878eed1" },
  "friendly-snippets": { "branch": "main", "commit": "efff286dd74c22f731cdec26a70b46e5b203c619" },
  "fzf": { "branch": "master", "commit": "7e4dbb5f3b93d38b20545a1e5a668e44cab440ce" },
  "fzf-lua": { "branch": "main", "commit": "aeff8132009a7fc55c6c43bca4288d5ba26a5393" },
  "gruvbox-material": { "branch": "master", "commit": "146f40fd42cbef30fed69b4ef51329aeeaceb909" },
  "lazy.nvim": { "branch": "main", "commit": "6c3bda4aca61a13a9c63f1c1d1b16b9d3be90d7a" },
  "lualine.nvim": { "branch": "master", "commit": "9fef261b53fbe3a2ef01ee9667f6fde064b1ed10" },
  "markdown-preview.nvim": { "branch": "master", "commit": "a923f5fc5ba36a3b17e289dc35dc17f66d0548ee" },
  "mason-lspconfig.nvim": { "branch": "main", "commit": "1a31f824b9cd5bc6f342fc29e9a53b60d74af245" },
  "mason.nvim": { "branch": "main", "commit": "fc98833b6da5de5a9c5b1446ac541577059555be" },
  "neovim-ayu": { "branch": "master", "commit": "f5da37a8ddd62fc3a7b28900c4d1b807a3582584" },
  "null-ls.nvim": { "branch": "main", "commit": "0010ea927ab7c09ef0ce9bf28c2b573fc302f5a7" },
  "nvim-cmp": { "branch": "main", "commit": "1e1900b0769324a9675ef85b38f99cca29e203b3" },
  "nvim-dap": { "branch": "master", "commit": "6a5bba0ddea5d419a783e170c20988046376090d" },
  "nvim-dap-ui": { "branch": "master", "commit": "bc81f8d3440aede116f821114547a476b082b319" },
  "nvim-dap-virtual-text": { "branch": "master", "commit": "df66808cd78b5a97576bbaeee95ed5ca385a9750" },
  "nvim-lspconfig": { "branch": "master", "commit": "699cf2ce74e40e7c5068cf93a6bd6a74b24c5ec3" },
  "nvim-nio": { "branch": "master", "commit": "21f5324bfac14e22ba26553caf69ec76ae8a7662" },
  "nvim-notify": { "branch": "master", "commit": "22f29093eae7785773ee9d543f8750348b1a195c" },
  "nvim-surround": { "branch": "main", "commit": "6c54643ef42016b744888b06d2381abd23f9b7ea" },
  "nvim-treesitter": { "branch": "master", "commit": "ff553df2f4c5641be2b282e1a0a072c46cf03591" },
  "nvim-web-devicons": { "branch": "master", "commit": "4c3a5848ee0b09ecdea73adcd2a689190aeb728c" },
  "ouroboros": { "branch": "master", "commit": "f528c0baf0b872b37036c166a144abcfc4752ec9" },
  "parrot.nvim": { "branch": "main", "commit": "3027b481ef58245147408455a13b61608a86885c" },
  "plenary.nvim": { "branch": "master", "commit": "857c5ac632080dba10aae49dba902ce3abf91b35" },
  "rnvimr": { "branch": "main", "commit": "57f7a8edd629791557d1315463d9fb2e411a45f1" },
  "tabular": { "branch": "master", "commit": "12437cd1b53488e24936ec4b091c9324cafee311" },
  "telescope-file-browser.nvim": { "branch": "master", "commit": "626998e5c1b71c130d8bc6cf7abb6709b98287bb" },
  "telescope-heading.nvim": { "branch": "main", "commit": "e85c0f69cb64048f56e76548dcb2f10277576df9" },
  "telescope.nvim": { "branch": "0.1.x", "commit": "a0bbec21143c7bc5f8bb02e0005fa0b982edc026" },
  "toast.vim": { "branch": "master", "commit": "6ef5cea8298e64a555cfaf7541bb94781d06dc69" },
  "toggletasks.nvim": { "branch": "master", "commit": "7138dda86bd4ec908ef5342e78c60bfbd23f4506" },
  "toggleterm.nvim": { "branch": "main", "commit": "50ea089fc548917cc3cc16b46a8211833b9e3c7c" },
  "trouble.nvim": { "branch": "main", "commit": "85bedb7eb7fa331a2ccbecb9202d8abba64d37b3" },
  "verilog_systemverilog.vim": { "branch": "master", "commit": "5d1ea7c50a66a2f6c6002214344b16de02996ecc" },
  "vim-dispatch": { "branch": "master", "commit": "a2ff28abdb2d89725192db5b8562977d392a4d3f" },
  "vim-easy-align": { "branch": "master", "commit": "9815a55dbcd817784458df7a18acacc6f82b1241" },
  "vim-fugitive": { "branch": "master", "commit": "4a745ea72fa93bb15dd077109afbb3d1809383f2" },
  "vim-illuminate": { "branch": "master", "commit": "19cb21f513fc2b02f0c66be70107741e837516a1" },
  "vim-jukit": { "branch": "master", "commit": "73214c9a8abc4b6aa7a6266b5bc2ddbf8b3e3c00" },
  "vim-markdown": { "branch": "master", "commit": "8f6cb3a6ca4e3b6bcda0730145a0b700f3481b51" },
  "vim-rooter": { "branch": "master", "commit": "51402fb77c4d6ae94994e37dc7ca13bec8f4afcc" },
  "vim-surround": { "branch": "master", "commit": "3d188ed2113431cf8dac77be61b842acb64433d9" },
  "vim-visual-multi": { "branch": "master", "commit": "a6975e7c1ee157615bbc80fc25e4392f71c344d4" },
  "vimtex": { "branch": "master", "commit": "ffd09d8493712ac8c2c570f8d5370b0572b6c5f6" },
  "yui": { "branch": "master", "commit": "b42cc9101b366c7876fc81c7ad799c56850c1f1c" }
}


==================================================
File: .svls.toml
==================================================

[options]
# SystemVerilog file extensions
fileExtensions = ["*.sv", "*.svh", "*.v", "*.vh"]

# Parser settings
[parser]
# Enable parsing of all relevant constructs
parseClassProperties = true
parseCovergroups = true
parseAssertions = true
parseConstraints = true

# Type hierarchy settings
[typeHierarchy]
enabled = true
depth = 3

# Include paths for standard libraries and UVM
[libraries]
# Add paths to any standard libraries you use
paths = [
    # Example UVM path (uncomment and modify as needed)
    # "/path/to/uvm/src"
]

# Preprocessor defines
[defines]
# Add any necessary defines here
values = []

# Workspace settings
[workspace]
# Library files or packages to include
libraryFiles = []
# Files to exclude
excludePatterns = ["**/sim/**", "**/tb/**"]
            

==================================================
File: init.lua
==================================================

-- ~/.config/nvim/init.lua
-- Main entry point for Neovim configuration
-- Add this to your init.lua (at the very top)
vim.g.jukit_enable_textcell_bg = 0  -- Disable the feature causing errors
vim.g.jukit_text_syntax_file = vim.fn.expand('$VIMRUNTIME/syntax/text.vim')
-- Set leader keys early to ensure consistent behavior
vim.g.mapleader = " "
vim.g.maplocalleader = "\\"
-- Ensure vim-jukit can find Python
vim.g.jukit_python_mode = 1
vim.g.jukit_shell_cmd = 'ipython3'

-- Add a small delay before initializing jukit
-- CHECK IF JUKIT HAVING PROBLEM
-- vim.defer_fn(function()
--   if vim.fn.has('python3') == 1 then
--     vim.notify("Python3 support confirmed for vim-jukit")
--   end
-- end, 1000)
-- Load initialization hooks early
require("init-hook").setup()
-- Set the Python provider path explicitly
-- Add near the top of init.lua (before loading lazy.nvim)
vim.g.python3_host_prog = '/usr/bin/python3'

-- Create a Python status check function
-- CHECK IF JUKIT HAVING PROBLEM
-- vim.defer_fn(function()
--   if vim.fn.has('python3') == 1 then
--     vim.notify("Python3 support confirmed")
--   else
--     vim.notify("Python3 support is NOT available!", vim.log.levels.WARN)
--   end
-- end, 500)
-- Optionally disable the health check
-- vim.g.loaded_python3_provider = 1
-- Detect operating system
local has = vim.fn.has
vim.g.os_current = nil
if has("mac") == 1 or has("macunix") == 1 then
  vim.g.os_current = "Darwin"
elseif has("unix") == 1 then
  vim.g.os_current = "Linux"
elseif has("win32") == 1 or has("win64") == 1 then
  vim.g.os_current = "Windows"
end

-- Bootstrap lazy.nvim
require("config.lazy")

-- Load core modules
require("config.options")  -- Vim options
require("config.keymaps")  -- Global keymaps
require("config.autocmds") -- Autocommands

-- Load utility modules
require("utils")

-- Load personal modules
local ok, personal_module = pcall(require, "personal")
if ok and personal_module then
  personal_module.setup()
else
  vim.notify("Failed to load personal modules: " .. tostring(personal_module), vim.log.levels.WARN)
end




==================================================
File: concatenated.txt
==================================================



==================================================
File: jukit_config.json
==================================================

{}


==================================================
File: lazy-lock.json
==================================================

{
  "Comment.nvim": { "branch": "master", "commit": "e30b7f2008e52442154b66f7c519bfd2f1e32acb" },
  "LuaSnip": { "branch": "master", "commit": "03c8e67eb7293c404845b3982db895d59c0d1538" },
  "clipboard-image.nvim": { "branch": "main", "commit": "4ab6f7f1fa4ea97866c0e0f6160f6a36ef174438" },
  "cmp-buffer": { "branch": "main", "commit": "3022dbc9166796b644a841a02de8dd1cc1d311fa" },
  "cmp-cmdline": { "branch": "main", "commit": "d250c63aa13ead745e3a40f61fdd3470efde3923" },
  "cmp-nvim-lsp": { "branch": "main", "commit": "99290b3ec1322070bcfb9e846450a46f6efa50f0" },
  "cmp-omni": { "branch": "main", "commit": "4ef610bbd85a5ee4e97e09450c0daecbdc60de86" },
  "cmp-path": { "branch": "main", "commit": "91ff86cd9c29299a64f968ebb45846c485725f23" },
  "cmp_luasnip": { "branch": "master", "commit": "98d9cb5c2c38532bd9bdb481067b20fea8f32e90" },
  "csv.vim": { "branch": "master", "commit": "b8eb7f67babce96168e7f6b93b2ba8328b72a390" },
  "flexoki": { "branch": "main", "commit": "9d382019eaa4fe8484d7a6ebde5b3890b878eed1" },
  "friendly-snippets": { "branch": "main", "commit": "efff286dd74c22f731cdec26a70b46e5b203c619" },
  "fzf": { "branch": "master", "commit": "7e4dbb5f3b93d38b20545a1e5a668e44cab440ce" },
  "fzf-lua": { "branch": "main", "commit": "aeff8132009a7fc55c6c43bca4288d5ba26a5393" },
  "gruvbox-material": { "branch": "master", "commit": "146f40fd42cbef30fed69b4ef51329aeeaceb909" },
  "lazy.nvim": { "branch": "main", "commit": "6c3bda4aca61a13a9c63f1c1d1b16b9d3be90d7a" },
  "lualine.nvim": { "branch": "master", "commit": "9fef261b53fbe3a2ef01ee9667f6fde064b1ed10" },
  "markdown-preview.nvim": { "branch": "master", "commit": "a923f5fc5ba36a3b17e289dc35dc17f66d0548ee" },
  "mason-lspconfig.nvim": { "branch": "main", "commit": "1a31f824b9cd5bc6f342fc29e9a53b60d74af245" },
  "mason.nvim": { "branch": "main", "commit": "fc98833b6da5de5a9c5b1446ac541577059555be" },
  "neovim-ayu": { "branch": "master", "commit": "f5da37a8ddd62fc3a7b28900c4d1b807a3582584" },
  "null-ls.nvim": { "branch": "main", "commit": "0010ea927ab7c09ef0ce9bf28c2b573fc302f5a7" },
  "nvim-cmp": { "branch": "main", "commit": "1e1900b0769324a9675ef85b38f99cca29e203b3" },
  "nvim-dap": { "branch": "master", "commit": "6a5bba0ddea5d419a783e170c20988046376090d" },
  "nvim-dap-ui": { "branch": "master", "commit": "bc81f8d3440aede116f821114547a476b082b319" },
  "nvim-dap-virtual-text": { "branch": "master", "commit": "df66808cd78b5a97576bbaeee95ed5ca385a9750" },
  "nvim-lspconfig": { "branch": "master", "commit": "699cf2ce74e40e7c5068cf93a6bd6a74b24c5ec3" },
  "nvim-nio": { "branch": "master", "commit": "21f5324bfac14e22ba26553caf69ec76ae8a7662" },
  "nvim-notify": { "branch": "master", "commit": "22f29093eae7785773ee9d543f8750348b1a195c" },
  "nvim-surround": { "branch": "main", "commit": "6c54643ef42016b744888b06d2381abd23f9b7ea" },
  "nvim-treesitter": { "branch": "master", "commit": "ff553df2f4c5641be2b282e1a0a072c46cf03591" },
  "nvim-web-devicons": { "branch": "master", "commit": "4c3a5848ee0b09ecdea73adcd2a689190aeb728c" },
  "ouroboros": { "branch": "master", "commit": "f528c0baf0b872b37036c166a144abcfc4752ec9" },
  "parrot.nvim": { "branch": "main", "commit": "3027b481ef58245147408455a13b61608a86885c" },
  "plenary.nvim": { "branch": "master", "commit": "857c5ac632080dba10aae49dba902ce3abf91b35" },
  "rnvimr": { "branch": "main", "commit": "57f7a8edd629791557d1315463d9fb2e411a45f1" },
  "tabular": { "branch": "master", "commit": "12437cd1b53488e24936ec4b091c9324cafee311" },
  "telescope-file-browser.nvim": { "branch": "master", "commit": "626998e5c1b71c130d8bc6cf7abb6709b98287bb" },
  "telescope-heading.nvim": { "branch": "main", "commit": "e85c0f69cb64048f56e76548dcb2f10277576df9" },
  "telescope.nvim": { "branch": "0.1.x", "commit": "a0bbec21143c7bc5f8bb02e0005fa0b982edc026" },
  "toast.vim": { "branch": "master", "commit": "6ef5cea8298e64a555cfaf7541bb94781d06dc69" },
  "toggletasks.nvim": { "branch": "master", "commit": "7138dda86bd4ec908ef5342e78c60bfbd23f4506" },
  "toggleterm.nvim": { "branch": "main", "commit": "50ea089fc548917cc3cc16b46a8211833b9e3c7c" },
  "trouble.nvim": { "branch": "main", "commit": "85bedb7eb7fa331a2ccbecb9202d8abba64d37b3" },
  "verilog_systemverilog.vim": { "branch": "master", "commit": "5d1ea7c50a66a2f6c6002214344b16de02996ecc" },
  "vim-dispatch": { "branch": "master", "commit": "a2ff28abdb2d89725192db5b8562977d392a4d3f" },
  "vim-easy-align": { "branch": "master", "commit": "9815a55dbcd817784458df7a18acacc6f82b1241" },
  "vim-fugitive": { "branch": "master", "commit": "4a745ea72fa93bb15dd077109afbb3d1809383f2" },
  "vim-illuminate": { "branch": "master", "commit": "19cb21f513fc2b02f0c66be70107741e837516a1" },
  "vim-jukit": { "branch": "master", "commit": "73214c9a8abc4b6aa7a6266b5bc2ddbf8b3e3c00" },
  "vim-markdown": { "branch": "master", "commit": "8f6cb3a6ca4e3b6bcda0730145a0b700f3481b51" },
  "vim-rooter": { "branch": "master", "commit": "51402fb77c4d6ae94994e37dc7ca13bec8f4afcc" },
  "vim-surround": { "branch": "master", "commit": "3d188ed2113431cf8dac77be61b842acb64433d9" },
  "vim-visual-multi": { "branch": "master", "commit": "a6975e7c1ee157615bbc80fc25e4392f71c344d4" },
  "vimtex": { "branch": "master", "commit": "ffd09d8493712ac8c2c570f8d5370b0572b6c5f6" },
  "yui": { "branch": "master", "commit": "b42cc9101b366c7876fc81c7ad799c56850c1f1c" }
}


==================================================
File: .svls.toml
==================================================

[options]
# SystemVerilog file extensions
fileExtensions = ["*.sv", "*.svh", "*.v", "*.vh"]

# Parser settings
[parser]
# Enable parsing of all relevant constructs
parseClassProperties = true
parseCovergroups = true
parseAssertions = true
parseConstraints = true

# Type hierarchy settings
[typeHierarchy]
enabled = true
depth = 3

# Include paths for standard libraries and UVM
[libraries]
# Add paths to any standard libraries you use
paths = [
    # Example UVM path (uncomment and modify as needed)
    # "/path/to/uvm/src"
]

# Preprocessor defines
[defines]
# Add any necessary defines here
values = []

# Workspace settings
[workspace]
# Library files or packages to include
libraryFiles = []
# Files to exclude
excludePatterns = ["**/sim/**", "**/tb/**"]
            

==================================================
File: init.lua
==================================================



==================================================
File: lua/init-hook.lua
==================================================

-- ~/.config/nvim/lua/init-hook.lua
local M = {}

function M.setup()
  -- Python provider configuration
  vim.g.python3_host_prog = vim.fn.exepath('python3')

  -- Check and notify about Python status
  vim.api.nvim_create_autocmd("VimEnter", {
    callback = function()
      -- Check Python support status
      local has_python = vim.fn.has('python3') == 1

      if not has_python then
        vim.notify([[
Python3 support is missing! For vim-jukit to work:

1. Install Python and pynvim:
   pip install pynvim

2. Verify Python path in init.lua:
   vim.g.python3_host_prog = ']] .. vim.g.python3_host_prog .. [['

3. Run :checkhealth provider
        ]], vim.log.levels.WARN)
      end
    end,
    once = true,
  })
end

return M


==================================================
File: lua/.svls.toml
==================================================

[options]
# SystemVerilog file extensions
fileExtensions = ["*.sv", "*.svh", "*.v", "*.vh"]

# Parser settings
[parser]
# Enable parsing of all relevant constructs
parseClassProperties = true
parseCovergroups = true
parseAssertions = true
parseConstraints = true

# Type hierarchy settings
[typeHierarchy]
enabled = true
depth = 3

# Include paths for standard libraries and UVM
[libraries]
# Add paths to any standard libraries you use
paths = [
    # Example UVM path (uncomment and modify as needed)
    # "/path/to/uvm/src"
]

# Preprocessor defines
[defines]
# Add any necessary defines here
values = []

# Workspace settings
[workspace]
# Library files or packages to include
libraryFiles = []
# Files to exclude
excludePatterns = ["**/sim/**", "**/tb/**"]
      

==================================================
File: lua/plugins/coding.lua
==================================================

-- ~/.config/nvim/lua/plugins/coding.lua
-- Coding-related plugins

return {
  -- Completion: nvim-cmp
  {
    "hrsh7th/nvim-cmp",
    dependencies = {
      "hrsh7th/cmp-nvim-lsp",     -- LSP source
      "hrsh7th/cmp-buffer",       -- Buffer source
      "hrsh7th/cmp-path",         -- Path source
      "hrsh7th/cmp-cmdline",      -- Command line source
      "hrsh7th/cmp-omni",         -- Omni completion source
      "saadparwaiz1/cmp_luasnip", -- Snippet source
      "L3MON4D3/LuaSnip",         -- Snippet engine
    },
    config = function()
      local cmp = require("cmp")
      local luasnip = require("luasnip")

      cmp.setup({
        snippet = {
          expand = function(args)
            luasnip.lsp_expand(args.body)
          end,
        },
        mapping = cmp.mapping.preset.insert({
          ['<C-b>'] = cmp.mapping.scroll_docs(-4),
          ['<C-f>'] = cmp.mapping.scroll_docs(4),
          ['<C-Space>'] = cmp.mapping.complete(),
          ['<C-e>'] = cmp.mapping.abort(),
          ['<CR>'] = cmp.mapping.confirm({ select = true }),
          ["<C-k>"] = cmp.mapping(function(fallback)
            if cmp.visible() then
              cmp.select_next_item()
            elseif luasnip.expand_or_jumpable() then
              luasnip.expand_or_jump()
            else
              fallback()
            end
          end, { "i", "s" }),
          ["<S-Tab>"] = cmp.mapping(function(fallback)
            if cmp.visible() then
              cmp.select_prev_item()
            elseif luasnip.jumpable(-1) then
              luasnip.jump(-1)
            else
              fallback()
            end
          end, { "i", "s" }),
        }),
        sources = cmp.config.sources({
          { name = 'nvim_lsp' },
          { name = 'luasnip' },
          { name = 'omni' },
          { name = 'buffer' },
          { name = 'path' },
        }),
        completion = {
          autocomplete = false, -- Disable automatic popup globally
        },
        experimental = {
          ghost_text = false,
        },
      })

      -- Use buffer source for `/` and `?`
      cmp.setup.cmdline({ '/', '?' }, {
        mapping = cmp.mapping.preset.cmdline(),
        sources = {
          { name = 'buffer' }
        }
      })

      -- Use cmdline & path source for ':'
      cmp.setup.cmdline(':', {
        mapping = cmp.mapping.preset.cmdline(),
        sources = cmp.config.sources({
          { name = 'path' }
        }, {
          { name = 'cmdline' }
        })
      })

      -- Set up a keymap to manually trigger completion
      vim.keymap.set('i', '<C-Space>', function()
        if cmp.visible() then
          cmp.close()
        else
          cmp.complete()
        end
      end, { silent = true })

      -- Special configuration for SystemVerilog files
      cmp.setup.filetype('systemverilog', {
        sources = cmp.config.sources({
          { name = 'nvim_lsp' },
          { name = 'luasnip' },
          { name = 'omni' },
          { name = 'buffer' },
          { name = 'path' },
        }),
        completion = {
          autocomplete = { 'TextChanged' } -- Specify events for auto-completion
        },
      })

      -- Special configuration for LaTeX files
      cmp.setup.filetype('tex', {
        sources = cmp.config.sources({
          { name = 'nvim_lsp' },
          { name = 'luasnip' },
          { name = 'omni' },
          { name = 'vimtex' },
          { name = 'buffer' },
          { name = 'path' },
        }),
        completion = {
          autocomplete = { 'TextChanged' } , -- Enable automatic popup for tex files
        },
      })
    end,
  },

  -- Snippets: LuaSnip
  {
    "L3MON4D3/LuaSnip",
    version = "v2.*",
    build = "make install_jsregexp",
    dependencies = {
      "rafamadriz/friendly-snippets", -- Collection of snippets
    },
    config = function()
      local ls = require("luasnip")

      ls.config.set_config({
        history = false,             -- Don't store snippet history for less overhead
        enable_autosnippets = true,  -- Allow autotrigger snippets
        store_selection_keys = "<Tab>", -- For equivalent of UltiSnips visual selection
        region_check_events = 'InsertEnter', -- Event on which to check for exiting a snippet's region
        delete_check_events = 'InsertLeave',
      })

      -- Load friendly-snippets
      require("luasnip.loaders.from_vscode").lazy_load()

      -- Load custom snippets
      require("luasnip.loaders.from_lua").lazy_load({paths = vim.fn.stdpath('config') .. "/snippets/"})

      -- Keymaps for snippet navigation
      vim.cmd([[
        " Jump forward
        imap <silent><expr> jk luasnip#jumpable(1) ? '<Plug>luasnip-jump-next' : 'jk'
        smap <silent><expr> jk luasnip#jumpable(1) ? '<Plug>luasnip-jump-next' : 'jk'

        " Jump backward
        imap <silent><expr> jh luasnip#jumpable(-1) ? '<Plug>luasnip-jump-prev' : 'jh'
        smap <silent><expr> jh luasnip#jumpable(-1) ? '<Plug>luasnip-jump-prev' : 'jh'

        " Cycle forward through choice nodes with Control-F
        imap <silent><expr> <C-f> luasnip#choice_active() ? '<Plug>luasnip-next-choice' : '<C-f>'
        smap <silent><expr> <C-f> luasnip#choice_active() ? '<Plug>luasnip-next-choice' : '<C-f>'
      ]])

      -- Command to refresh snippets
      vim.keymap.set('', '<Leader>U',
        '<Cmd>lua require("luasnip.loaders.from_lua").lazy_load({paths = "' .. vim.fn.stdpath('config') .. '/snippets/"})<CR><Cmd>echo "Snippets refreshed!"<CR>',
        { desc = "Refresh snippets" })
    end,
  },

  -- Syntax support for SystemVerilog
  {
    "vhda/verilog_systemverilog.vim",
    ft = { "verilog", "systemverilog" },
    config = function()
      vim.g.verilog_syntax_fold_lst = "block,function,task,specify,module,class,covergroup"
      vim.g.verilog_disable_indent_lst = "eos"
      vim.g.verilog_indent_modules = 1
      vim.g.verilog_indent_width = 2
    end,
  },

  -- In lua/plugins/coding.lua
  {
    "luk400/vim-jukit",
    lazy = false,      -- Don't lazy load this plugin
    priority = 1000,   -- Highest priority to load very early
    init = function()  -- Execute before plugin loads
      -- Force the correct syntax file path
      vim.g.jukit_text_syntax_file = vim.fn.expand('$VIMRUNTIME/syntax/markdown.vim')

      -- Check if file exists and use fallback if needed
      if vim.fn.filereadable(vim.g.jukit_text_syntax_file) ~= 1 then
        vim.g.jukit_text_syntax_file = vim.fn.expand('$VIMRUNTIME/syntax/text.vim')
      end

      -- Other vim-jukit settings
      vim.g.python3_host_prog = '/usr/bin/python3'
      vim.g.jukit_shell_cmd = 'ipython3'
      vim.g.jukit_terminal = 'nvimterm'
      vim.g.jukit_auto_output_hist = 1
      vim.g.jukit_use_tcomment = 1
      vim.g.jukit_enable_textcell_bg = 0  -- Try disabling this feature

      -- Print path for debugging
      -- vim.api.nvim_create_autocmd("VimEnter", {
      --   callback = function()
      --     vim.notify("vim-jukit using syntax file: " .. vim.g.jukit_text_syntax_file)
      --   end,
      --   once = true
      -- })
    end
  },
  -- Clipboard image saver
  {
    "postfen/clipboard-image.nvim",
    config = function()
      require('clipboard-image').setup {
        default = {
          img_dir = vim.fn.expand("~/Pictures/clipboard_images"),
          img_dir_txt = vim.fn.expand("~/Pictures/clipboard_images"),
          img_name = function()
            return "screenshot_" .. os.date("%Y%m%d%H%M%S") .. "_" .. math.random(1000)
          end,
          affix = "![clipboard_image](%s)"
        }
      }
    end,
  },

  -- Markdown preview
  {
    "iamcco/markdown-preview.nvim",
    build = "cd app && npm install",
    ft = { "markdown" },
    cmd = { "MarkdownPreview", "MarkdownPreviewStop" },
    init = function()
      vim.g.mkdp_auto_close = 1
      vim.g.mkdp_refresh_slow = 1
    end,
  },

  -- Markdown support
  {
    "preservim/vim-markdown",
    dependencies = { "godlygeek/tabular" },
    ft = { "markdown" },
    init = function()
      vim.g.vim_markdown_folding_disabled = 1
      vim.g.vim_markdown_conceal = 2
      vim.g.vim_markdown_conceal_code_blocks = 0
      vim.g.vim_markdown_math = 1
      vim.g.vim_markdown_frontmatter = 1
      vim.g.vim_markdown_strikethrough = 1
    end,
  },

  -- Additional coding tools
  {
    "jakemason/ouroboros",  -- File navigation
  },

  -- FZF
  {
    "junegunn/fzf",
    build = function() vim.fn['fzf#install']() end,
  },

  {
    "ibhagwan/fzf-lua",
    dependencies = { "nvim-tree/nvim-web-devicons" },
  },

}


==================================================
File: lua/plugins/ui.lua
==================================================

-- ~/.config/nvim/lua/plugins/ui.lua
-- UI-related plugins

return {
  -- Colorscheme: Gruvbox Material
  {
    "sainnhe/gruvbox-material",
    lazy = false,
    priority = 1000, -- Load colorscheme before other plugins
    config = function()
      -- Configure Gruvbox Material
      vim.g.gruvbox_material_background = "soft"
      vim.g.gruvbox_material_ui_contrast = "high"
      vim.g.gruvbox_material_foreground = "original"
      vim.g.gruvbox_material_enable_italic = 1
      vim.g.gruvbox_material_enable_bold = 1
      vim.g.gruvbox_material_better_performance = 1

      -- Set the colorscheme
      vim.cmd("colorscheme gruvbox-material")
    end,
  },

  -- Statusline: Lualine
  {
    "nvim-lualine/lualine.nvim",
    dependencies = { "nvim-tree/nvim-web-devicons" },
    config = function()
      require("lualine").setup({
        options = {
          icons_enabled = true,
          theme = "auto",
          component_separators = { left = "", right = "" },
          section_separators = { left = "", right = "" },
          disabled_filetypes = {},
          always_divide_middle = true,
          globalstatus = false,
        },
        sections = {
          lualine_a = { "mode" },
          lualine_b = { "branch", "diff", "diagnostics" },
          lualine_c = { { "filename", path = 1 } },
          lualine_x = { "encoding", "filetype" },
          lualine_y = { "progress" },
          lualine_z = { "location" }
        },
        inactive_sections = {
          lualine_a = {},
          lualine_b = {},
          lualine_c = { { "filename", path = 1 } },
          lualine_x = { "location" },
          lualine_y = {},
          lualine_z = {}
        },
        tabline = {},
        extensions = {}
      })
    end,
  },

  -- Notifications: nvim-notify
  {
    "rcarriga/nvim-notify",
    config = function()
      require("notify").setup({
        background_colour = "#000000",
        render = "compact",
        top_down = false,
      })

      -- Set nvim-notify as the default notification handler
      vim.notify = require("notify")
    end,
  },

  -- Trouble: Better diagnostics window
  {
    "folke/trouble.nvim",
    dependencies = { "nvim-tree/nvim-web-devicons" },
    cmd = { "Trouble", "TroubleToggle" },
    config = function()
      require("trouble").setup({
        -- Default configuration
      })

      -- Keymaps
      vim.keymap.set("n", "<leader>xx", "<cmd>Trouble<cr>",
        { silent = true, noremap = true, desc = "Trouble: Open diagnostics" })
    end,
  },

  -- Other UI-related plugins
  {
    "nvim-tree/nvim-web-devicons",
    lazy = true,
  },

  -- Colorscheme collection for variety
  {
    "kepano/flexoki",
    lazy = true,
    priority = 900,
  },

  {
    "Shatur/neovim-ayu",
    lazy = true,
    priority = 900,
  },

  {
    "cideM/yui",
    lazy = true,
    priority = 900,
  },

  {
    "jsit/toast.vim",
    lazy = true,
    priority = 900,
  },
}


==================================================
File: lua/plugins/editor.lua
==================================================

-- ~/.config/nvim/lua/plugins/editor.lua
-- Editor enhancement plugins

return {
  -- Telescope: Fuzzy finder
  {
    "nvim-telescope/telescope.nvim",
    dependencies = {
      "nvim-lua/plenary.nvim",
      "nvim-telescope/telescope-file-browser.nvim",
      "crispgm/telescope-heading.nvim",
    },
    branch = "0.1.x",
    config = function()
      require("telescope").setup({
        defaults = {
          file_ignore_patterns = {"node_modules"},
          layout_strategy = 'vertical',
          layout_config = { height = 0.95, width = 0.95 },
        },
        pickers = {
          find_files = {
            theme = "dropdown",
            layout_config = {
              width = 0.9, -- 90% of screen width
            },
          }
        },
        extensions = {
          file_browser = {
            theme = "ivy",
            hijack_netrw = true,
          },
        },
      })

      -- Load extensions
      require("telescope").load_extension("file_browser")
      require("telescope").load_extension("heading")
    end,
  },

  -- Treesitter: Better syntax highlighting
  {
    "nvim-treesitter/nvim-treesitter",
    build = ":TSUpdate",
    config = function()
      require("nvim-treesitter.configs").setup({
        ensure_installed = "all",
        highlight = {
          enable = true,
        },
        indent = {
          enable = true,
        },
      })
    end,
  },

  -- Comment.nvim: Easy commenting
  {
    "numToStr/Comment.nvim",
    config = function()
      require("Comment").setup({
        padding = true,
        sticky = true,
        ignore = nil,
        toggler = {
          line = 'gll',
          block = 'gcc',
        },
        opleader = {
          line = 'gl',
          block = 'gc',
        },
        extra = {
          above = 'gcO',
          below = 'gco',
          eol = 'gcA',
        },
        mappings = {
          basic = true,
          extra = true,
          extended = false,
        },
      })
    end,
  },

  -- Surround: Handle surrounding delimiters
  {
    "kylechui/nvim-surround",
    version = "*",
    event = "VeryLazy",
    config = function()
      require("nvim-surround").setup({
        -- Configuration here, or leave empty for defaults
      })
    end
  },

  -- CSV.vim: CSV file handling
  {
    "chrisbra/csv.vim",
    ft = {"csv", "tsv"},
    config = function()
      -- Recognize .tsv files as CSV with tab delimiter
      vim.g.csv_extensions = {'csv', 'tsv'}

      -- Set tab as the default delimiter for .tsv files
      vim.api.nvim_create_autocmd({"BufRead", "BufNewFile"}, {
        pattern = "*.tsv",
        callback = function()
          vim.b.csv_delimiter = "\t"
        end
      })

      -- Create a command for non-.tsv files
      vim.api.nvim_create_user_command('TSV', function()
        vim.bo.filetype = 'csv'
        vim.b.csv_delimiter = "\t"
      end, {})

      -- Set up key mappings for CSV mode
      vim.api.nvim_create_autocmd("FileType", {
        pattern = "csv",
        callback = function()
          local opts = { noremap = true, silent = true, buffer = true }
          vim.keymap.set('n', '<C-k>', '<Plug>CSV_KernelSort', opts)
          vim.keymap.set('n', '<C-j>', '<Plug>CSV_WhatColumn', opts)
          vim.keymap.set('n', '<C-h>', '<Plug>CSV_HiColumn', opts)
          vim.keymap.set('n', '<C-l>', '<Plug>CSV_NrColumns', opts)
        end
      })
    end,
  },

  -- Ranger integration
  {
    "kevinhwang91/rnvimr",
    config = function()
      -- Make Ranger replace Netrw and be the file explorer
      vim.g.rnvimr_enable_ex = 1

      -- Make Ranger to be hidden after picking a file
      vim.g.rnvimr_enable_picker = 1

      -- Replace `$EDITOR` candidate with this command to open the selected file
      vim.g.rnvimr_edit_cmd = 'drop'

      -- Disable a border for floating window
      vim.g.rnvimr_draw_border = 0

      -- Hide the files included in gitignore
      vim.g.rnvimr_hide_gitignore = 1

      -- Make Neovim wipe the buffers corresponding to the files deleted by Ranger
      vim.g.rnvimr_enable_bw = 1

      -- Add a shadow window, value is equal to 100 will disable shadow
      vim.g.rnvimr_shadow_winblend = 70
    end,
  },

  -- Rooter: Change working directory to project root
  {
    "airblade/vim-rooter",
    config = function()
      vim.g.rooter_patterns = {'.git', 'Makefile', 'package.json', '.root', 'build/env.sh'}
      vim.g.rooter_manual_only = 1

      -- Keymapping
      vim.keymap.set('', '<Leader>tr', '<Cmd>Rooter<CR>', { noremap = true, silent = true, desc = "Change to project root" })
    end,
  },

  -- Toggle Tasks: Project task management
  {
    "jedrzejboczar/toggletasks.nvim",
    dependencies = {
      "nvim-lua/plenary.nvim",
      "akinsho/toggleterm.nvim",
      "nvim-telescope/telescope.nvim",
    },
    config = function()
      require('toggletasks').setup({})
      require('telescope').load_extension('toggletasks')

      -- Function to spawn task by name
      local function spawn_by_name(name)
        local tasks = require('toggletasks.discovery').tasks():filter(function(task)
          return task.config.name == name
        end)

        if #tasks > 0 then
          tasks[1]:spawn()
          tasks[1].term:open()
        else
          print("No matching task with name", name)
        end
      end

      -- Function to spawn tasks with tag
      local function spawn_tasks_with_tag(tag)
        local tasks = require('toggletasks.discovery').tasks():filter(function(task)
          return vim.tbl_contains(task.config.tags or {}, tag)
        end)

        if #tasks > 0 then
          for _, task in pairs(tasks) do
            task:spawn()
            task.term:open()
          end
        else
          print("No matching tasks with tag", tag)
        end
      end

      -- Keymappings
      vim.keymap.set('n', '<space>ts', require('telescope').extensions.toggletasks.spawn,
        { desc = "Tasks: Open task picker" })

      -- Run all tasks with the #serve tag
      vim.keymap.set('n', '<Leader>ts', function()
        vim.cmd("Rooter")  -- switch to project root directory
        spawn_tasks_with_tag("serve")
        vim.cmd("wincmd k")  -- Return cursor to original window
        vim.cmd("stopinsert")  -- Return to normal mode
      end, { desc = "Tasks: Run serve tasks" })

      -- Run all tasks with the #run tag
      vim.keymap.set('n', '<Leader>tp', function()
        vim.cmd("Rooter")  -- switch to project root directory
        spawn_tasks_with_tag("run")
        vim.cmd("wincmd k")  -- Return cursor to original window
        vim.cmd("stopinsert")  -- Return to normal mode
      end, { desc = "Tasks: Run run tasks" })

      -- Run all tasks with the #build tag
      vim.keymap.set('n', '<Leader>to', function()
        vim.cmd("Rooter")  -- switch to project root directory
        spawn_tasks_with_tag("build")
        vim.cmd("wincmd k")  -- Return cursor to original window
        vim.cmd("stopinsert")  -- Return to normal mode
      end, { desc = "Tasks: Run build tasks" })

      -- Run all tasks with the #view tag
      vim.keymap.set('n', '<Leader>ti', function()
        vim.cmd("Rooter")  -- switch to project root directory
        spawn_tasks_with_tag("view")
        vim.cmd("wincmd k")  -- Return cursor to original window
        vim.cmd("stopinsert")  -- Return to normal mode
      end, { desc = "Tasks: Run view tasks" })
    end,
  },

  -- ToggleTerm: Better terminal integration
  {
    "akinsho/toggleterm.nvim",
    version = "*",
    config = function()
      require("toggleterm").setup({
        -- shade_terminals = false,
        open_mapping = [[<c-\>]], -- or { [[<c-\>]], [[<c-¥>]] } if you also use a Japanese keyboard.
      })

      -- Keymappings
      vim.keymap.set('n', '<Leader>tt', '<Cmd>ToggleTerm<CR>',
        { noremap = true, silent = true, desc = "Toggle terminal" })
      vim.keymap.set('n', '<Leader>t1', '<Cmd>1ToggleTerm<CR>',
        { noremap = true, silent = true, desc = "Toggle terminal 1" })
      vim.keymap.set('n', '<Leader>t2', '<Cmd>2ToggleTerm<CR>',
        { noremap = true, silent = true, desc = "Toggle terminal 2" })
    end,
  },

  -- Easy Align: Alignment tool
  {
    "junegunn/vim-easy-align",
    config = function()
      -- Start interactive EasyAlign in visual mode (e.g. vipga)
      vim.keymap.set('x', 'ga', '<Plug>(EasyAlign)',
        { desc = "EasyAlign in visual mode" })

      -- Start interactive EasyAlign for a motion/text object (e.g. gaip)
      vim.keymap.set('n', 'ga', '<Plug>(EasyAlign)',
        { desc = "EasyAlign for motion" })
    end,
  },

  -- Additional useful editor plugins
  {
    "tpope/vim-fugitive",  -- Git integration
  },

  {
    "tpope/vim-surround",  -- Surround text objects
  },

  {
    "mg979/vim-visual-multi",  -- Multiple cursors
  },
}


==================================================
File: lua/plugins/.svls.toml
==================================================

[options]
# SystemVerilog file extensions
fileExtensions = ["*.sv", "*.svh", "*.v", "*.vh"]

# Parser settings
[parser]
# Enable parsing of all relevant constructs
parseClassProperties = true
parseCovergroups = true
parseAssertions = true
parseConstraints = true

# Type hierarchy settings
[typeHierarchy]
enabled = true
depth = 3

# Include paths for standard libraries and UVM
[libraries]
# Add paths to any standard libraries you use
paths = [
    # Example UVM path (uncomment and modify as needed)
    # "/path/to/uvm/src"
]

# Preprocessor defines
[defines]
# Add any necessary defines here
values = []

# Workspace settings
[workspace]
# Library files or packages to include
libraryFiles = []
# Files to exclude
excludePatterns = ["**/sim/**", "**/tb/**"]
            

==================================================
File: lua/plugins/lsp.lua
==================================================

-- ~/.config/nvim/lua/plugins/lsp.lua
-- LSP-related plugins

return {
  -- LSP Configuration
  {
    "neovim/nvim-lspconfig",
    event = { "BufReadPre", "BufNewFile" },
    dependencies = {
      "hrsh7th/cmp-nvim-lsp",            -- LSP completion
      "williamboman/mason.nvim",          -- Portable package manager for Neovim
      "williamboman/mason-lspconfig.nvim", -- Bridges mason.nvim with lspconfig
    },
    config = function()
      -- Set up Mason
      require("mason").setup({
        ui = {
          icons = {
            package_installed = "✓",
            package_pending = "➜",
            package_uninstalled = "✗"
          }
        }
      })

      -- Set up Mason-lspconfig
      require("mason-lspconfig").setup({
        ensure_installed = {
          "lua_ls",            -- Lua
          "pyright",           -- Python
          "clangd",            -- C/C++
        },
        automatic_installation = true,
      })

      -- LSP handlers configuration
      local handlers = {
        ["textDocument/hover"] = vim.lsp.with(
          vim.lsp.handlers.hover, { border = "rounded" }
        ),
        ["textDocument/signatureHelp"] = vim.lsp.with(
          vim.lsp.handlers.signature_help, { border = "rounded" }
        ),
      }

      -- Diagnostic configuration
      vim.diagnostic.config({
        virtual_text = false,
        signs = true,
        underline = true,
        update_in_insert = false,
        severity_sort = true,
        float = {
          border = "rounded",
          source = "always",
          header = "",
          prefix = "",
        },
      })

      -- Set diagnostic signs
      local signs = { Error = " ", Warn = " ", Hint = " ", Info = " " }
      for type, icon in pairs(signs) do
        local hl = "DiagnosticSign" .. type
        vim.fn.sign_define(hl, { text = icon, texthl = hl, numhl = hl })
      end

      -- Global LSP on_attach function
      local on_attach = function(client, bufnr)
        -- Enable completion triggered by <c-x><c-o>
        vim.api.nvim_buf_set_option(bufnr, 'omnifunc', 'v:lua.vim.lsp.omnifunc')

        -- Buffer local mappings
        local opts = { noremap = true, silent = true, buffer = bufnr }
        vim.keymap.set('n', 'gD', vim.lsp.buf.declaration,
          vim.tbl_extend("force", opts, { desc = "LSP: Go to declaration" }))
        vim.keymap.set('n', 'gd', vim.lsp.buf.definition,
          vim.tbl_extend("force", opts, { desc = "LSP: Go to definition" }))
        vim.keymap.set('n', 'K', vim.lsp.buf.hover,
          vim.tbl_extend("force", opts, { desc = "LSP: Hover information" }))
        vim.keymap.set('n', 'gi', vim.lsp.buf.implementation,
          vim.tbl_extend("force", opts, { desc = "LSP: Go to implementation" }))
        vim.keymap.set('n', '<C-k>', vim.lsp.buf.signature_help,
          vim.tbl_extend("force", opts, { desc = "LSP: Signature help" }))
        vim.keymap.set('n', '<space>D', vim.lsp.buf.type_definition,
          vim.tbl_extend("force", opts, { desc = "LSP: Type definition" }))
        vim.keymap.set('n', '<space>rn', vim.lsp.buf.rename,
          vim.tbl_extend("force", opts, { desc = "LSP: Rename" }))
        vim.keymap.set({ 'n', 'v' }, '<space>ca', vim.lsp.buf.code_action,
          vim.tbl_extend("force", opts, { desc = "LSP: Code action" }))
        vim.keymap.set('n', 'gr', vim.lsp.buf.references,
          vim.tbl_extend("force", opts, { desc = "LSP: References" }))
        vim.keymap.set('n', '<space>f', function()
          vim.lsp.buf.format { async = true }
        end, vim.tbl_extend("force", opts, { desc = "LSP: Format buffer" }))

        -- Enable inlay hints if supported (with proper version checking)
        if client.server_capabilities.inlayHintProvider then
          -- Check Neovim version for proper API support
          if vim.fn.has("nvim-0.10.0") == 1 then
            -- Safe call with pcall to prevent errors
            pcall(function()
              vim.lsp.inlay_hint.enable(bufnr, true)
            end)
          end
        end

        -- Set up document highlight
        if client.server_capabilities.documentHighlightProvider then
          local group = vim.api.nvim_create_augroup("LSPDocumentHighlight", { clear = false })
          vim.api.nvim_clear_autocmds({ buffer = bufnr, group = group })
          vim.api.nvim_create_autocmd({ "CursorHold", "CursorHoldI" }, {
            buffer = bufnr,
            group = group,
            callback = vim.lsp.buf.document_highlight,
          })
          vim.api.nvim_create_autocmd("CursorMoved", {
            buffer = bufnr,
            group = group,
            callback = vim.lsp.buf.clear_references,
          })
        end
      end

      -- Default capabilities
      local capabilities = require("cmp_nvim_lsp").default_capabilities()

      -- Configure individual language servers
      local lspconfig = require("lspconfig")

      -- Lua
      lspconfig.lua_ls.setup({
        capabilities = capabilities,
        on_attach = on_attach,
        handlers = handlers,
        settings = {
          Lua = {
            diagnostics = {
              globals = { "vim" }, -- Recognize 'vim' global
            },
            workspace = {
              library = {
                vim.env.VIMRUNTIME,
                "${3rd}/luv/library",
                "${3rd}/busted/library",
              },
              checkThirdParty = false,
            },
            telemetry = {
              enable = false,
            },
          },
        },
      })

      -- Python
      lspconfig.pyright.setup({
        capabilities = capabilities,
        on_attach = on_attach,
        handlers = handlers,
        settings = {
          python = {
            analysis = {
              typeCheckingMode = "basic",
              autoSearchPaths = true,
              useLibraryCodeForTypes = true,
            },
          },
        },
      })

      -- C/C++
      lspconfig.clangd.setup({
        capabilities = capabilities,
        on_attach = on_attach,
        handlers = handlers,
        cmd = {
          "clangd",
          "--background-index",
          "--suggest-missing-includes",
          "--clang-tidy",
          "--header-insertion=iwyu",
        },
      })

      -- SystemVerilog
      lspconfig.svls.setup({
        capabilities = capabilities,
        on_attach = function(client, bufnr)
          on_attach(client, bufnr)

          -- Disable diagnostics for SystemVerilog files
          vim.diagnostic.disable(bufnr)

          print("SystemVerilog LSP attached with enhanced context support")
        end,
        handlers = handlers,
        settings = {
          systemverilog = {
            -- File indexing configuration
            includeIndexing = {
              "**/*.sv",
              "**/*.svh",
              "**/*.v",
              "**/*.vh"
            },
            excludeIndexing = {
              "**/sim/**",
              "**/tb/**"
            },
            -- Library paths - important for finding built-in classes and methods
            libraryFiles = {
              "**/*.sv",
              "**/*.svh",
              "**/*.v",
              "**/*.vh"
            },
            -- Enhanced feature set
            features = {
              classContext = true,
              memberCompletion = true,
              hover = true,
              signatureHelp = true,
              -- Additional features for better context awareness
              semanticHighlighting = true,
              documentSymbols = true,
              documentFormatting = true
            },
            -- Parser configuration for better context understanding
            parser = {
              -- Enable class and covergroup parsing
              parseClassProperties = true,
              parseCovergroups = true,
              parseAssertions = true,
              parseConstraints = true
            },
            -- Type information
            typeHierarchy = {
              enabled = true,
              depth = 3
            }
          }
        },
        -- Improved workspace configuration
        root_dir = function(fname)
          local util = require('lspconfig.util')
          return util.root_pattern(
            'svls.toml',
            '.svls.toml',
            '.git',
            'package.sv'
          )(fname) or util.path.dirname(fname)
        end
      })

-- Replace the ensure_svls_config function with this improved version:
local function ensure_svls_config()
  local cwd = vim.fn.getcwd()
  local config_file = cwd .. '/.svls.toml'
  if vim.fn.filereadable(config_file) == 0 then
    local f = io.open(config_file, 'w')
    if f then
      f:write([[
[options]
# SystemVerilog file extensions
fileExtensions = ["*.sv", "*.svh", "*.v", "*.vh"]

# Parser settings
[parser]
# Enable parsing of all relevant constructs
parseClassProperties = true
parseCovergroups = true
parseAssertions = true
parseConstraints = true

# Type hierarchy settings
[typeHierarchy]
enabled = true
depth = 3

# Include paths for standard libraries and UVM
[libraries]
# Add paths to any standard libraries you use
paths = [
    # Example UVM path (uncomment and modify as needed)
    # "/path/to/uvm/src"
]

# Preprocessor defines
[defines]
# Add any necessary defines here
values = []

# Workspace settings
[workspace]
# Library files or packages to include
libraryFiles = []
# Files to exclude
excludePatterns = ["**/sim/**", "**/tb/**"]
      ]])
      f:close()
      print("Created enhanced SVLS config file at " .. config_file)
    end
  end
end

      -- Automatically create SVLS config
      ensure_svls_config()
    end,
  },

  -- Null-LS - Additional diagnostics, formatting, and code actions
  {
    "jose-elias-alvarez/null-ls.nvim",
    dependencies = {
      "nvim-lua/plenary.nvim",
    },
    config = function()
      local null_ls = require("null-ls")

      -- Verilator diagnostic for SystemVerilog
      local verilator = null_ls.builtins.diagnostics.verilator.with({
        extra_args = { "--lint-only", "-Wall", "-I" .. (os.getenv("UVM_HOME") or "") .. "/src"},
        method = null_ls.methods.DIAGNOSTICS_ON_SAVE,
      })

      local update_in_progress = false

      null_ls.setup({
        sources = { verilator },
        on_attach = function(client, bufnr)
          local augroup = vim.api.nvim_create_augroup("NullLsDiagnostics", { clear = true })
          vim.api.nvim_create_autocmd({ "CursorHold", "BufWritePost" }, {
            group = augroup,
            buffer = bufnr,
            callback = function()
              if not update_in_progress then
                update_in_progress = true
                vim.defer_fn(function()
                  vim.diagnostic.show()
                  update_in_progress = false
                end, 100)  -- 100ms delay
              end
            end,
          })
        end,
      })
    end,
  },

  -- Enhanced text illumination
  {
    "RRethy/vim-illuminate",
    config = function()
      vim.cmd [[
        let g:Illuminate_useDeprecated = 1
        let g:Illuminate_ftwhitelist = ['python, c, php']
      ]]

      -- Set the highlighting style
      vim.api.nvim_command [[hi def link LspReferenceText CursorLine]]
      vim.api.nvim_command [[hi def link LspReferenceWrite CursorLine]]
      vim.api.nvim_command [[hi def link LspReferenceRead CursorLine]]
    end,
  },

  -- Debugging with DAP (Core functionality)
  {
    "mfussenegger/nvim-dap",
    config = function()
      -- Get the DAP module safely
      local status_ok, dap = pcall(require, "dap")
      if not status_ok then
        vim.notify("nvim-dap not available", vim.log.levels.WARN)
        return
      end

      -- Set up key mappings for DAP
      vim.keymap.set('n', '<Leader>dp', function() dap.continue() end,
        { desc = "Debug: Continue" })

      vim.keymap.set('n', '<Leader>dn', function() dap.step_over() end,
        { desc = "Debug: Step over" })
      vim.keymap.set('n', '<Leader>di', function() dap.step_into() end,
        { desc = "Debug: Step into" })
      vim.keymap.set('n', '<Leader>do', function() dap.step_out() end,
        { desc = "Debug: Step out" })

      vim.keymap.set('n', '<Leader>dd', function() dap.toggle_breakpoint() end,
        { desc = "Debug: Toggle breakpoint" })
      vim.keymap.set('n', '<Leader>dD', function() dap.set_breakpoint() end,
        { desc = "Debug: Set breakpoint" })
      vim.keymap.set('n', '<Leader>dl', function() dap.set_breakpoint(nil, nil, vim.fn.input('Log point message: ')) end,
        { desc = "Debug: Set log point" })

      vim.keymap.set('n', '<Leader>dr', function() dap.repl.toggle() end,
        { desc = "Debug: Toggle REPL" })

      vim.keymap.set('n', '<Leader>dl', function() dap.run_last() end,
        { desc = "Debug: Run last" })
    end,
  },

  -- DAP UI - Enhanced debugging UI
  {
    "rcarriga/nvim-dap-ui",
    dependencies = {
      "mfussenegger/nvim-dap", -- Explicit dependency
      "nvim-neotest/nvim-nio"
    },
    config = function()
      -- Safely load dapui module
      local status_ok, dapui = pcall(require, "dapui")
      if not status_ok then
        vim.notify("nvim-dap-ui not available", vim.log.levels.WARN)
        return
      end

      -- Set up DAPUI
      dapui.setup({
        -- Default configuration
        icons = { expanded = "▾", collapsed = "▸", current_frame = "→" },
        mappings = {
          expand = { "<CR>", "<2-LeftMouse>" },
          open = "o",
          remove = "d",
          edit = "e",
          repl = "r",
          toggle = "t",
        },
        layouts = {
          {
            elements = {
              { id = "scopes", size = 0.25 },
              "breakpoints",
              "stacks",
              "watches",
            },
            size = 40,
            position = "left",
          },
          {
            elements = {
              "repl",
              "console",
            },
            size = 10,
            position = "bottom",
          },
        },
        floating = {
          max_height = nil,
          max_width = nil,
          border = "single",
          mappings = {
            close = { "q", "<Esc>" },
          },
        },
        windows = { indent = 1 },
        render = {
          max_type_length = nil,
          max_value_lines = 100,
        }
      })

      -- Now, safely get DAP for event handling
      local dap_status, dap = pcall(require, "dap")
      if dap_status then
        -- Set up automatic UI open/close with debugging sessions
        dap.listeners.after.event_initialized["dapui_config"] = function()
          dapui.open()
        end
        dap.listeners.before.event_terminated["dapui_config"] = function()
          dapui.close()
        end
        dap.listeners.before.event_exited["dapui_config"] = function()
          dapui.close()
        end
      end

      -- Additional keymaps for DAP UI
      vim.keymap.set({'n', 'v'}, '<Leader>dh', function()
        local widgets_status, widgets = pcall(require, 'dap.ui.widgets')
        if widgets_status then
          widgets.hover()
        end
      end, { desc = "Debug: Hover" })

      vim.keymap.set({'n', 'v'}, '<Leader>dv', function()
        local widgets_status, widgets = pcall(require, 'dap.ui.widgets')
        if widgets_status then
          widgets.preview()
        end
      end, { desc = "Debug: Preview" })

      vim.keymap.set('n', '<Leader>df', function()
        local widgets_status, widgets = pcall(require, 'dap.ui.widgets')
        if widgets_status then
          widgets.centered_float(widgets.frames)
        end
      end, { desc = "Debug: Show frames" })

      vim.keymap.set('n', '<Leader>ds', function()
        local widgets_status, widgets = pcall(require, 'dap.ui.widgets')
        if widgets_status then
          widgets.centered_float(widgets.scopes)
        end
      end, { desc = "Debug: Show scopes" })
    end,
  },

  -- DAP Virtual Text - Shows values on top of code while debugging
  {
    "theHamsta/nvim-dap-virtual-text",
    dependencies = {
      "mfussenegger/nvim-dap",
      "nvim-treesitter/nvim-treesitter",
    },
    config = function()
      -- Safely load virtual text module
      local status_ok, virtual_text = pcall(require, "nvim-dap-virtual-text")
      if not status_ok then
        vim.notify("nvim-dap-virtual-text not available", vim.log.levels.WARN)
        return
      end

      -- Configure virtual text
      virtual_text.setup {
        enabled = true,
        enabled_commands = true,
        highlight_changed_variables = true,
        highlight_new_as_changed = false,
        show_stop_reason = true,
        commented = false,
        virt_text_pos = 'eol',
        all_frames = false,
        virt_lines = false,
        virt_text_win_col = nil
      }
    end,
  },
}


==================================================
File: lua/plugins/tex.lua
==================================================

-- File: lua/plugins/tex.lua
return {
  "lervag/vimtex",
  lazy = false,      -- CRITICAL: Load on startup, not lazy-loaded
  priority = 1000,   -- High priority to load before other plugins
  ft = {"tex", "latex"},
  init = function()
    -- OS detection (from tex.vim)
    if not vim.g.os_current then
      if vim.fn.has("win64") == 1 or vim.fn.has("win32") == 1 or vim.fn.has("win16") == 1 then
        vim.g.os_current = "Windows"
      else
        vim.g.os_current = vim.fn.system('uname'):gsub('\n', '')
      end
    end

    -- From tex.vim
    vim.g.tex_flavor = 'latex'  -- recognize tex files as latex
    vim.g.tex_indent_items = 0  -- Turn off automatic indenting in enumerated environments

    -- From vimtex.vim - compiler settings
    vim.g.vimtex_compiler_method = 'latexmk'
    vim.g.vimtex_compiler_latexmk = {
      build_dir = '',
      options = {
        '-pdf',
        '-shell-escape',
        '-verbose',
        '-file-line-error',
        '-synctex=1',
        '-interaction=nonstopmode',
      },
    }

    -- CRITICAL SETTINGS TO FIX SYNTAX HIGHLIGHTING
    vim.g.vimtex_syntax_enabled = 1
    vim.g.vimtex_syntax_conceal_enable = 1

    -- VimTeX view settings
    vim.g.vimtex_view_method = 'zathura'
    vim.g.vimtex_view_general_options = [[--unique file:@pdf\#src:@line@tex]]

    -- Compiler settings - ensure nvr is used for server
    vim.g.vimtex_compiler_progname = 'nvr'

    -- QuickFix settings
    vim.g.vimtex_quickfix_open_on_warning = 0
    vim.g.vimtex_quickfix_ignore_filters = {
      'Underfull \\hbox',
      'Overfull \\hbox',
      'LaTeX Warning: .\\+ float specifier changed to',
      'LaTeX hooks Warning',
      'Package siunitx Warning: Detected the "physics" package:',
      'Package hyperref Warning: Token not allowed in a PDF string',
    }
  end,
  config = function()
    -- Create a TeX settings group
    local tex_group = vim.api.nvim_create_augroup("vimtex_config", { clear = true })

    -- TeX file detection
    vim.api.nvim_create_autocmd({"BufRead", "BufNewFile"}, {
      pattern = {"*.tex", "*.sty", "*.dtx", "*.ltx", "*.cls"},
      callback = function()
        vim.bo.filetype = "tex"
      end,
    })

    -- Set up TeX indentation (from tex.vim)
    vim.api.nvim_create_autocmd("FileType", {
      group = tex_group,
      pattern = "tex",
      callback = function()
        vim.opt_local.expandtab = true
        vim.opt_local.autoindent = true
        vim.opt_local.tabstop = 4
        vim.opt_local.softtabstop = 4
        vim.opt_local.shiftwidth = 4

        -- Ensure VimTeX is initialized
        if vim.fn.exists('*vimtex#init') == 1 then
          vim.cmd('call vimtex#init()')
        end

        -- Enable syntax highlighting
        vim.cmd('syntax enable')

        -- Write inverse search target (from tex.vim)
        vim.fn.system('echo TEX > /tmp/inverse-search-target.txt')
      end
    })

    -- Get Vim's window ID for switching focus from Zathura to Vim using xdotool.
    if vim.g.os_current == "Linux" and not vim.g.vim_window_id then
      vim.g.vim_window_id = vim.fn.system("xdotool getactivewindow")
    end

    -- Forward search implementation (from tex.vim)
    if vim.g.os_current == "Linux" then
      vim.api.nvim_create_autocmd("User", {
        group = tex_group,
        pattern = "VimtexEventView",
        callback = function()
          -- Give window manager time to recognize focus moved to Zathura
          vim.cmd("sleep 200m")
          vim.cmd("!xdotool windowfocus " .. vim.g.vim_window_id)
          vim.cmd("redraw!")
        end
      })
    elseif vim.g.os_current == "Darwin" then
      vim.api.nvim_create_autocmd("User", {
        group = tex_group,
        pattern = "VimtexEventViewReverse",
        callback = function()
          vim.cmd("!open -a Alacritty")
          vim.cmd("redraw!")
        end
      })
    end

    -- Close viewers when VimTeX buffers are closed (from vimtex.vim)
    vim.api.nvim_create_autocmd("User", {
      group = tex_group,
      pattern = "VimtexEventQuit",
      callback = function()
        if vim.fn.executable('xdotool') == 1 and
           vim.b.vimtex and vim.b.vimtex.viewer and
           vim.b.vimtex.viewer.xwin_id and
           vim.b.vimtex.viewer.xwin_id > 0 then
          vim.fn.system('xdotool windowclose ' .. vim.b.vimtex.viewer.xwin_id)
        end
      end
    })

    -- Toggle shell escape function (from vimtex.vim)
    local function toggle_shell_escape()
      if not vim.g.vimtex_compiler_latexmk or not vim.g.vimtex_compiler_latexmk.options then
        vim.notify("VimTeX compiler options not properly set up", vim.log.levels.ERROR)
        return
      end

      local options = vim.g.vimtex_compiler_latexmk.options
      local shell_escape_index = nil

      for i, option in ipairs(options) do
        if option == '-shell-escape' then
          shell_escape_index = i
          break
        end
      end

      if shell_escape_index then
        -- Disable shell escape
        table.remove(options, shell_escape_index)
        vim.notify("Shell escape disabled")
      else
        -- Enable shell escape
        table.insert(options, '-shell-escape')
        vim.notify("Shell escape enabled")
      end

      vim.cmd("VimtexReload")
      vim.cmd("VimtexClean")
    end

    -- Register the TexToggleShellEscape command
    vim.api.nvim_create_user_command('TexToggleShellEscape', toggle_shell_escape, {})

    -- Set up key mappings (from tex.vim and vimtex.vim)
    vim.api.nvim_create_autocmd("FileType", {
      group = tex_group,
      pattern = "tex",
      callback = function()
        -- Compilation commands (from tex.vim)
        vim.keymap.set("n", "<leader>c", "<Cmd>update<CR><Cmd>VimtexCompileSS<CR>", {buffer = true})
        vim.keymap.set("n", "<leader>r", "<Cmd>update<CR><Cmd>VimtexCompileSS<CR>", {buffer = true})
        vim.keymap.set("n", "<leader>v", "<plug>(vimtex-view)", {buffer = true})
        vim.keymap.set("n", "<leader>i", "<plug>(vimtex-info)", {buffer = true})
        vim.keymap.set("n", "<leader>t", "<Cmd>VimtexTocToggle<CR>", {buffer = true})
        vim.keymap.set("n", "<leader>te", "<Cmd>TexToggleShellEscape<CR>", {buffer = true})

        -- Define mappings (from vimtex.vim)
        -- Delete mappings
        vim.keymap.set("n", "dse", "<plug>(vimtex-env-delete)", {buffer = true})
        vim.keymap.set("n", "dsc", "<plug>(vimtex-cmd-delete)", {buffer = true})
        vim.keymap.set("n", "dsm", "<plug>(vimtex-env-delete-math)", {buffer = true})
        vim.keymap.set("n", "dsd", "<plug>(vimtex-delim-delete)", {buffer = true})

        -- Change mappings
        vim.keymap.set("n", "cse", "<plug>(vimtex-env-change)", {buffer = true})
        vim.keymap.set("n", "csc", "<plug>(vimtex-cmd-change)", {buffer = true})
        vim.keymap.set("n", "csm", "<plug>(vimtex-env-change-math)", {buffer = true})
        vim.keymap.set("n", "csd", "<plug>(vimtex-delim-change-math)", {buffer = true})

        -- Toggle mappings
        vim.keymap.set("n", "tsf", "<plug>(vimtex-cmd-toggle-frac)", {buffer = true})
        vim.keymap.set("n", "tsc", "<plug>(vimtex-cmd-toggle-star)", {buffer = true})
        vim.keymap.set("n", "tse", "<plug>(vimtex-env-toggle-star)", {buffer = true})
        vim.keymap.set("n", "tsd", "<plug>(vimtex-delim-toggle-modifier)", {buffer = true})
        vim.keymap.set("n", "tsD", "<plug>(vimtex-delim-toggle-modifier-reverse)", {buffer = true})
        vim.keymap.set("n", "tsm", "<plug>(vimtex-env-toggle-math)", {buffer = true})
        vim.keymap.set("i", "]]", "<plug>(vimtex-delim-close)", {buffer = true})

        -- Text objects (from vimtex.vim)
        -- Command text objects
        vim.keymap.set("o", "ac", "<plug>(vimtex-ac)", {buffer = true})
        vim.keymap.set("x", "ac", "<plug>(vimtex-ac)", {buffer = true})
        vim.keymap.set("o", "ic", "<plug>(vimtex-ic)", {buffer = true})
        vim.keymap.set("x", "ic", "<plug>(vimtex-ic)", {buffer = true})

        -- Delimiter text objects
        vim.keymap.set("o", "ad", "<plug>(vimtex-ad)", {buffer = true})
        vim.keymap.set("x", "ad", "<plug>(vimtex-ad)", {buffer = true})
        vim.keymap.set("o", "id", "<plug>(vimtex-id)", {buffer = true})
        vim.keymap.set("x", "id", "<plug>(vimtex-id)", {buffer = true})

        -- Environment text objects
        vim.keymap.set("o", "ae", "<plug>(vimtex-ae)", {buffer = true})
        vim.keymap.set("x", "ae", "<plug>(vimtex-ae)", {buffer = true})
        vim.keymap.set("o", "ie", "<plug>(vimtex-ie)", {buffer = true})
        vim.keymap.set("x", "ie", "<plug>(vimtex-ie)", {buffer = true})

        -- Math text objects
        vim.keymap.set("o", "am", "<plug>(vimtex-a$)", {buffer = true})
        vim.keymap.set("x", "am", "<plug>(vimtex-a$)", {buffer = true})
        vim.keymap.set("o", "im", "<plug>(vimtex-i$)", {buffer = true})
        vim.keymap.set("x", "im", "<plug>(vimtex-i$)", {buffer = true})

        -- Item text objects
        vim.keymap.set("o", "ai", "<plug>(vimtex-am)", {buffer = true})
        vim.keymap.set("x", "ai", "<plug>(vimtex-am)", {buffer = true})
        vim.keymap.set("o", "ii", "<plug>(vimtex-im)", {buffer = true})
        vim.keymap.set("x", "ii", "<plug>(vimtex-im)", {buffer = true})

        -- Section/paragraph text objects
        vim.keymap.set("o", "aP", "<plug>(vimtex-aP)", {buffer = true})
        vim.keymap.set("x", "aP", "<plug>(vimtex-aP)", {buffer = true})
        vim.keymap.set("o", "iP", "<plug>(vimtex-iP)", {buffer = true})
        vim.keymap.set("x", "iP", "<plug>(vimtex-iP)", {buffer = true})

        -- Motion mappings
        vim.keymap.set("", "%", "<plug>(vimtex-%)", {buffer = true})
        vim.keymap.set("", "]]", "<plug>(vimtex-]])", {buffer = true})
        vim.keymap.set("", "][", "<plug>(vimtex-][)", {buffer = true})
        vim.keymap.set("", "[]", "<plug>(vimtex-[])", {buffer = true})
        vim.keymap.set("", "[[", "<plug>(vimtex-[[)", {buffer = true})

        -- Section motions
        vim.keymap.set("", "]m", "<plug>(vimtex-]m)", {buffer = true})
        vim.keymap.set("", "]M", "<plug>(vimtex-]M)", {buffer = true})
        vim.keymap.set("", "[m", "<plug>(vimtex-[m)", {buffer = true})
        vim.keymap.set("", "[M", "<plug>(vimtex-[M)", {buffer = true})

        -- Environment motions
        vim.keymap.set("", "]n", "<plug>(vimtex-]n)", {buffer = true})
        vim.keymap.set("", "]N", "<plug>(vimtex-]N)", {buffer = true})
        vim.keymap.set("", "[n", "<plug>(vimtex-[n)", {buffer = true})
        vim.keymap.set("", "[N", "<plug>(vimtex-[N)", {buffer = true})

        -- Item motions
        vim.keymap.set("", "]r", "<plug>(vimtex-]r)", {buffer = true})
        vim.keymap.set("", "]R", "<plug>(vimtex-]R)", {buffer = true})
        vim.keymap.set("", "[r", "<plug>(vimtex-[r)", {buffer = true})
        vim.keymap.set("", "[R", "<plug>(vimtex-[R)", {buffer = true})

        -- Comment motions
        vim.keymap.set("", "]/", "<plug>(vimtex-]/)", {buffer = true})
        vim.keymap.set("", "]*", "<plug>(vimtex-]star)", {buffer = true})
        vim.keymap.set("", "[/", "<plug>(vimtex-[/)", {buffer = true})
        vim.keymap.set("", "[*", "<plug>(vimtex-[star)", {buffer = true})

        -- Check for minted package and enable shell escape if needed
        local cmd = 'head -n 20 ' .. vim.fn.expand('%') .. ' | grep "minted" > /dev/null'
        local result = vim.fn.system(cmd)
        if vim.v.shell_error == 0 then -- minted found
          if not vim.tbl_contains(vim.g.vimtex_compiler_latexmk.options, '-shell-escape') then
            table.insert(vim.g.vimtex_compiler_latexmk.options, '-shell-escape')
            vim.notify("Shell escape enabled for minted package")
          end
        end
      end
    })

    -- Add a debug command to check VimTeX status
    vim.api.nvim_create_user_command('CheckVimtex', function()
      vim.notify("VimTeX loaded: " .. tostring(vim.fn.exists('*vimtex#init')))
      local cmds = vim.fn.getcompletion('Vimtex', 'cmdline')
      vim.notify("Available VimTeX commands: " .. vim.inspect(cmds))
      vim.notify("Current filetype: " .. vim.bo.filetype)
      vim.notify("Syntax enabled: " .. tostring(vim.g.syntax_on or vim.g.syntax_manual))
    end, {})
  end
}


==================================================
File: lua/plugins/tools.lua
==================================================

-- ~/.config/nvim/lua/plugins/tools.lua
-- Tools and utilities

return {
  -- Parrot.nvim - AI integration
  {
    "frankroeder/parrot.nvim",
    dependencies = {
      "ibhagwan/fzf-lua",
      "nvim-lua/plenary.nvim",
      "rcarriga/nvim-notify"
    },
    config = function()
      require("parrot").setup({
        providers = {
          anthropic = {
            api_key = os.getenv "ANTHROPIC_API_KEY",
            endpoint = "https://api.anthropic.com/v1/messages",
            topic_prompt = "You only respond with 3 to 4 words to summarize the past conversation.",
            topic = {
              model = "claude-3-haiku-20240307",
              params = { max_tokens = 32 },
            },
            params = {
              chat = { max_tokens = 4096 },
              command = { max_tokens = 4096 },
            },
          },
          -- ollama = {},
          xai = {
            api_key = os.getenv "XAI_API_KEY",
          },
          nvidia = {
            api_key = os.getenv "NVIDIA_API_KEY",
          },
          deepseek = {
            style = "openai",
            api_key = os.getenv "DEEPSEEK_API_KEY",
            endpoint = "https://api.deepseek.com/v1/chat/completions",
            models = {
              "deepseek-chat",      -- DeepSeek-V3
              "deepseek-reasoner",  -- DeepSeek-R1
            },
            -- parameters to summarize chat
            topic = {
              model = "deepseek-chat",
              params = { max_completion_tokens = 64 },
            },
            -- default parameters
            params = {
              chat = { temperature = 0.7, top_p = 1 },    -- using standard temperature
              command = { temperature = 0.7, top_p = 1 },
            },
          }
        },

        cmd_prefix = "Prt",
        chat_conceal_model_params = false,
        user_input_ui = "buffer",
        toggle_target = "vsplit",
        online_model_selection = true,
        command_auto_select_response = true,

        hooks = {
          Complete = function(prt, params)
            local template = [[
            I have the following code from {{filename}}:

            ```{{filetype}}
            {{selection}}
            ```

            Please finish the code above carefully and logically.
            Respond just with the snippet of code that should be inserted."
            ]]
            local model_obj = prt.get_model "command"
            prt.Prompt(params, prt.ui.Target.append, model_obj, nil, template)
          end,

          CompleteFullContext = function(prt, params)
            local template = [[
            I have the following code from {{filename}}:

            ```{{filetype}}
            {{filecontent}}
            ```

            Please look at the following section specifically:
            ```{{filetype}}
            {{selection}}
            ```

            Please finish the code above carefully and logically.
            Respond just with the snippet of code that should be inserted.
            ]]
            local model_obj = prt.get_model "command"
            prt.Prompt(params, prt.ui.Target.append, model_obj, nil, template)
          end,

          CompleteMultiContext = function(prt, params)
            local template = [[
            I have the following code from {{filename}} and other realted files:

            ```{{filetype}}
            {{multifilecontent}}
            ```

            Please look at the following section specifically:
            ```{{filetype}}
            {{selection}}
            ```

            Please finish the code above carefully and logically.
            Respond just with the snippet of code that should be inserted.
            ]]
            local model_obj = prt.get_model "command"
            prt.Prompt(params, prt.ui.Target.append, model_obj, nil, template)
          end,

          Explain = function(prt, params)
            local template = [[
            Your task is to take the code snippet from {{filename}} and explain it with gradually increasing complexity.
            Break down the code's functionality, purpose, and key components.
            The goal is to help the reader understand what the code does and how it works.

            ```{{filetype}}
            {{selection}}
            ```

            Use the markdown format with codeblocks and inline code. Explanation of the code above:
            ]]
            local model = prt.get_model "command"
            prt.logger.info("Explaining selection with model: " .. model.name)
            prt.Prompt(params, prt.ui.Target.new, model, nil, template)
          end,

          ExplainWithContext = function(prt, params)
            local template = [[
            Your task is to take the code snippet from {{filename}} and explain it with gradually increasing complexity.
            Break down the code's functionality, purpose, and key components.
            The goal is to help the reader understand what the code does and how it works.

            Below is the snippet to be mindful of.
            ```{{filetype}}
            {{selection}}
            ```

            Below is the full file content
            ```{{filetype}}
            {{filecontent}}
            ```

            Use the markdown format with codeblocks and inline code. Explanation of the code above:
            ]]
            local model = prt.get_model "command"
            prt.logger.info("Explaining selection with model: " .. model.name)
            prt.Prompt(params, prt.ui.Target.new, model, nil, template)
          end,

          FixBugs = function(prt, params)
            local template = [[
            You are an expert in {{filetype}}.
            Fix bugs in the below code from {{filename}} carefully and logically:
            Your task is to analyze the provided {{filetype}} code snippet, identify
            any bugs or errors present, and provide a corrected version of the code
            that resolves these issues. Explain the problems you found in the
            original code and how your fixes address them. The corrected code should
            be functional, efficient, and adhere to best practices in
            {{filetype}} programming.

            ```{{filetype}}
            {{selection}}
            ```

            Fixed code:
            ]]
            local model_obj = prt.get_model "command"
            prt.logger.info("Fixing bugs in selection with model: " .. model_obj.name)
            prt.Prompt(params, prt.ui.Target.new, model_obj, nil, template)
          end,

          Optimize = function(prt, params)
            local template = [[
            You are an expert in {{filetype}}.
            Your task is to analyze the provided {{filetype}} code snippet and
            suggest improvements to optimize its performance. Identify areas
            where the code can be made more efficient, faster, or less
            resource-intensive. Provide specific suggestions for optimization,
            along with explanations of how these changes can enhance the code's
            performance. The optimized code should maintain the same functionality
            as the original code while demonstrating improved efficiency.

            ```{{filetype}}
            {{selection}}
            ```

            Optimized code:
            ]]
            local model_obj = prt.get_model "command"
            prt.logger.info("Optimizing selection with model: " .. model_obj.name)
            prt.Prompt(params, prt.ui.Target.new, model_obj, nil, template)
          end,

          UnitTests = function(prt, params)
            local template = [[
            I have the following code from {{filename}}:

            ```{{filetype}}
            {{selection}}
            ```

            Please respond by writing table driven unit tests for the code above.
            ]]
            local model_obj = prt.get_model "command"
            prt.logger.info("Creating unit tests for selection with model: " .. model_obj.name)
            prt.Prompt(params, prt.ui.Target.enew, model_obj, nil, template)
          end,

          Debug = function(prt, params)
            local template = [[
            I want you to act as {{filetype}} expert.
            Review the following code, carefully examine it, and report potential
            bugs and edge cases alongside solutions to resolve them.
            Keep your explanation short and to the point:

            ```{{filetype}}
            {{selection}}
            ```
            ]]
            local model_obj = prt.get_model "command"
            prt.logger.info("Debugging selection with model: " .. model_obj.name)
            prt.Prompt(params, prt.ui.Target.enew, model_obj, nil, template)
          end,

          CommitMsg = function(prt, params)
            local futils = require "parrot.file_utils"
            if futils.find_git_root() == "" then
              prt.logger.warning "Not in a git repository"
              return
            else
              local template = [[
              I want you to act as a commit message generator. I will provide you
              with information about the task and the prefix for the task code, and
              I would like you to generate an appropriate commit message using the
              conventional commit format. Do not write any explanations or other
              words, just reply with the commit message.
              Start with a short headline as summary but then list the individual
              changes in more detail.

              Here are the changes that should be considered by this message:
              ]] .. vim.fn.system "git diff --no-color --no-ext-diff --staged"
              local model_obj = prt.get_model "command"
              prt.Prompt(params, prt.ui.Target.append, model_obj, nil, template)
            end
          end,

          SpellCheck = function(prt, params)
            local chat_prompt = [[
            Your task is to take the text provided and rewrite it into a clear,
            grammatically correct version while preserving the original meaning
            as closely as possible. Correct any spelling mistakes, punctuation
            errors, verb tense issues, word choice problems, and other
            grammatical mistakes.
            ]]
            prt.ChatNew(params, chat_prompt)
          end,

          CodeConsultant = function(prt, params)
            local chat_prompt = [[
              Your task is to analyze the provided {{filetype}} code and suggest
              improvements to optimize its performance. Identify areas where the
              code can be made more efficient, faster, or less resource-intensive.
              Provide specific suggestions for optimization, along with explanations
              of how these changes can enhance the code's performance. The optimized
              code should maintain the same functionality as the original code while
              demonstrating improved efficiency.

              Here is the code
              ```{{filetype}}
              {{filecontent}}
              ```
            ]]
            prt.ChatNew(params, chat_prompt)
          end,

          ProofReader = function(prt, params)
            local chat_prompt = [[
            I want you to act as a proofreader. I will provide you with texts and
            I would like you to review them for any spelling, grammar, or
            punctuation errors. Once you have finished reviewing the text,
            provide me with any necessary corrections or suggestions to improve the
            text. Highlight the corrected fragments (if any) using markdown backticks.

            When you have done that subsequently provide me with a slightly better
            version of the text, but keep close to the original text.

            Finally provide me with an ideal version of the text.

            Whenever I provide you with text, you reply in this format directly:

            ## Corrected text:

            {corrected text, or say "NO_CORRECTIONS_NEEDED" instead if there are no corrections made}

            ## Slightly better text

            {slightly better text}

            ## Ideal text

            {ideal text}
            ]]
            prt.ChatNew(params, chat_prompt)
          end
        }
      })
    end,
  },

  -- Dispatch - Asynchronous build and test dispatcher
  {
    "tpope/vim-dispatch",
    cmd = { "Dispatch", "Make", "Focus", "Start" },
    init = function()
      -- Disable vim-dispatch's default key mappings
      vim.g.dispatch_no_maps = 1
    end,
  },

  -- Plenary - Lua utility functions
  {
    "nvim-lua/plenary.nvim",
    lazy = true,
  },

}


==================================================
File: lua/plugins/treesitter.lua
==================================================

-- File: lua/plugins/treesitter.lua
return {
  "nvim-treesitter/nvim-treesitter",
  build = ":TSUpdate",
  priority = 600,  -- Load before most plugins but after critical ones
  config = function()
    require("nvim-treesitter.configs").setup({
      -- A list of parser names, or "all" (parsers with maintainers)
      ensure_installed = {
        "lua",      -- For Neovim config files
        "vim",      -- For Vim script files
        "vimdoc",   -- For help files
        "latex",    -- For LaTeX files
        "bibtex",   -- For BibTeX files
        "markdown", -- For documentation
        "bash",     -- For shell scripts
        "python",   -- If you work with Python
      },

      -- Install parsers synchronously (only applied to `ensure_installed`)
      sync_install = false,

      -- Automatically install missing parsers when entering buffer
      auto_install = true,

      -- List of parsers to ignore installing (for "all")
      ignore_install = {},

      highlight = {
        enable = true,  -- Enable TreeSitter highlighting

        -- Disable highlighting for specific filetypes
        disable = {},

        -- Setting this to true will run `:h syntax` and tree-sitter at the same time.
        -- Using this option may slow down your editor, and you may see duplicate highlights.
        additional_vim_regex_highlighting = false,
      },

      indent = {
        enable = true,  -- Enable TreeSitter-based indentation
        disable = {"tex"}, -- Disable TS indentation for tex files as VimTeX handles this better
      },
    })
  end,
}


==================================================
File: lua/plugins/config/jukit.lua
==================================================

-- ~/.config/nvim/lua/plugins/config/jukit.lua
local M = {}

function M.setup()
  -- Explicitly set the Python path
  vim.g.python3_host_prog = '/usr/bin/python3'

  -- Force vim-jukit to use Python directly instead of through Neovim's interface
  vim.g.jukit_python_configured = 1  -- Tell jukit we're handling Python ourselves
  vim.g.jukit_shell_cmd = 'ipython3' -- Use IPython

  -- Set terminal type
  vim.g.jukit_terminal = 'nvimterm'

  -- Other jukit settings
  vim.g.jukit_auto_output_hist = 1
  vim.g.jukit_use_tcomment = 1
  vim.g.jukit_enable_textcell_bg = 1
  vim.g.jukit_text_syntax_file = 'markdown'

  -- Initialize the plugin with a delay to ensure Python provider is ready
  vim.defer_fn(function()
    -- Create a force-initialization command
    vim.api.nvim_create_user_command("JukitInitialize", function()
      -- This forces jukit to initialize using our settings
      vim.cmd("let g:jukit_python3_support = 1")
      vim.cmd("runtime plugin/jukit.vim")
      vim.notify("vim-jukit initialized with Python support")
    end, {})

    -- Run initialization
    vim.cmd("JukitInitialize")
  end, 1000)  -- 1 second delay
end

return M


==================================================
File: lua/plugins/.jukit/.jukit_info.json
==================================================

{"terminal": "nvimterm"}

==================================================
File: lua/config/keymaps.lua
==================================================

-- ~/.config/nvim/lua/config/keymaps.lua
-- Global keymaps

local map = vim.keymap.set
local opts = { noremap = true, silent = true }

-- Helper function for key mapping with description
local function desc_map(mode, lhs, rhs, description, map_opts)
  local merged_opts = vim.tbl_extend("force", 
    opts, 
    map_opts or {}, 
    { desc = description }
  )
  map(mode, lhs, rhs, merged_opts)
end

-- Window navigation
desc_map("n", "<C-h>", "<C-w>h", "Move to left window")
desc_map("n", "<C-j>", "<C-w>j", "Move to bottom window")
desc_map("n", "<C-k>", "<C-w>k", "Move to top window")
desc_map("n", "<C-l>", "<C-w>l", "Move to right window")

-- Terminal window navigation
desc_map("t", "<C-h>", "<C-\\><C-n><C-w>h", "Terminal: Move to left window")
desc_map("t", "<C-j>", "<C-\\><C-n><C-w>j", "Terminal: Move to bottom window")
desc_map("t", "<C-k>", "<C-\\><C-n><C-w>k", "Terminal: Move to top window")
desc_map("t", "<Esc>", "<C-\\><C-n>", "Terminal: Enter normal mode")

-- Tab management
desc_map("n", "<TAB>", ":tabnext<CR>", "Go to next tab")
desc_map("n", "<S-TAB>", ":tabprev<CR>", "Go to previous tab")
desc_map("n", "<C-t>", ":tabnew<CR>", "Create new tab")
desc_map("n", "<Leader>tn", ":tabnew<CR>", "Tab: Create new")
desc_map("n", "<Leader>tc", ":tabclose<CR>", "Tab: Close")
desc_map("n", "<Leader>l", ":tabnext<CR>", "Tab: Go next")
desc_map("n", "<Leader>h", ":tabprevious<CR>", "Tab: Go previous")
desc_map("n", "<A-l>", ":tabnext<CR>", "Tab: Go next (Alt)")
desc_map("n", "<A-h>", ":tabprevious<CR>", "Tab: Go previous (Alt)")
desc_map("n", "<Leader>tm", ":tabmove<Space>", "Tab: Move position", { noremap = true })
desc_map("n", "<Leader>to", ":tabedit<Space>", "Tab: Open file", { noremap = true })

-- Quick tab access (1-9)
for i = 1, 9 do
  desc_map("n", "<Leader>" .. i, i .. "gt", "Tab: Go to #" .. i)
end

-- Buffer management
desc_map("n", "<A-j>", ":bnext<CR>", "Buffer: Go next")
desc_map("n", "<A-k>", ":bprevious<CR>", "Buffer: Go previous")
desc_map("n", "<Leader>bn", ":bnext<CR>", "Buffer: Go next")
desc_map("n", "<Leader>bp", ":bprevious<CR>", "Buffer: Go previous")
desc_map("n", "<Leader>bd", ":bdelete<CR>", "Buffer: Delete")
desc_map("n", "<Leader>ba", ":badd<Space>", "Buffer: Add new", { noremap = true })
desc_map("n", "<Leader>bl", ":buffers<CR>", "Buffer: List all")
desc_map("n", "<Leader>bw", ":write<CR>:bdelete<CR>", "Buffer: Write and close")
desc_map("n", "<Leader>bs", ":<C-u>buffers<CR>:buffer<Space>", "Buffer: Switch to")

-- Quick buffer access (Alt+1-9)
for i = 1, 9 do
  desc_map("n", "<A-" .. i .. ">", ":buffer " .. i .. "<CR>", "Buffer: Go to #" .. i)
end

-- File management
desc_map("n", "<Leader>w", ":write<CR>", "Save file")
desc_map("n", "<Leader>q", ":quit<CR>", "Quit")
desc_map("n", "<Leader>wq", ":wq<CR>", "Save and quit")
desc_map("n", "<Leader>wa", ":wall<CR>", "Save all")
desc_map("n", "<Leader>qa", ":qall<CR>", "Quit all")

-- Telescope
desc_map("n", "<Leader>ff", function() require('telescope.builtin').find_files() end, "Find Files")
desc_map("n", "<Leader>fg", function() require('telescope.builtin').live_grep() end, "Find Text")
desc_map("n", "<Leader>fb", function() require('telescope.builtin').buffers() end, "Find Buffers")
desc_map("n", "<Leader>fh", function() require('telescope.builtin').help_tags() end, "Find Help")
desc_map("n", "<Leader>fr", function() require('telescope.builtin').oldfiles() end, "Find Recent")
desc_map("n", "<Leader>fc", function() require('telescope.builtin').current_buffer_fuzzy_find() end, "Find in Current Buffer")
desc_map("n", "<Leader>fm", function() require('telescope.builtin').marks() end, "Find Marks")
desc_map("n", "<Leader>fk", function() require('telescope.builtin').keymaps() end, "Find Keymaps")
desc_map("n", "<Leader>fs", function() require('telescope.builtin').git_status() end, "Find Git Status")

-- File explorer with Ranger
desc_map("n", "<Leader>rr", ":RnvimrToggle<CR>", "Toggle Ranger file explorer")

-- Markdown preview
desc_map("n", "<Leader>m", ":MarkdownPreview<CR>", "Markdown preview")

-- Reload config
desc_map("n", "<Leader>re", ":ReloadConfig<CR>", "Reload configuration")

-- Yank message history 
desc_map("n", "<leader>ym", [[:redir @+ | :message | :redir END<CR>]], "Yank message history to clipboard")

-- Parrot AI integration
desc_map("n", "<Leader>pr", ":PrtChatResponde<CR>", "AI: Chat respond")
desc_map("n", "<Leader>prr", ":PrtChatNew<CR>", "AI: New chat")
desc_map("n", "<Leader>pp", ":PrtProvider<CR>", "AI: Provider selection")
desc_map("n", "<Leader>pa", ":PrtAsk<CR>", "AI: Ask a question")
desc_map("n", "<Leader>pf", ":PrtChatFinder<CR>", "AI: Chat finder")
desc_map("n", "<Leader>pm", ":PrtModel<CR>", "AI: Model selection")
desc_map("n", "<Leader>pt", ":PrtThinking<CR>", "AI: Enable thinking")
desc_map("n", "<Leader>pts", ":PrtThinking status<CR>", "AI: Thinking status")

-- AI Visual mode shortcuts
local function keymapOptions(desc)
  return {
    noremap = true,
    silent = true,
    nowait = true,
    desc = "AI: " .. desc,
  }
end

map("v", "<C-p>r", ":<C-u>'<,'>PrtRewrite<cr>", keymapOptions("Visual Rewrite"))
map("v", "<C-p>a", ":<C-u>'<,'>PrtAppend<cr>", keymapOptions("Visual Append (after)"))
map("v", "<C-p>b", ":<C-u>'<,'>PrtPrepend<cr>", keymapOptions("Visual Prepend (before)"))
map("v", "<C-p>i", ":<C-u>'<,'>PrtImplement<cr>", keymapOptions("Implement selection"))
map("v", "<C-p>e", ":<C-u>'<,'>PrtExplain ", keymapOptions("Explain selection"))
map("v", "<C-p>ee", ":<C-u>'<,'>PrtExplainWithContext ", keymapOptions("Explain selection with context"))

-- Personal notes
desc_map("n", "<Leader>pn", ":PersistentNotes<CR>", "Open persistent notes")
desc_map("n", "<Leader>tn", ":TemporaryNotes<CR>", "Open temporary notes")
desc_map("n", "<Leader>rn", ":RandomNote<CR>", "Create random note")
desc_map("n", "<Leader>ns", ":SearchNotes<CR>", "Search in notes")
desc_map("n", "<Leader>ng", ":GrepRandomNotes<CR>", "Grep random notes")


==================================================
File: lua/config/autocmds.lua
==================================================

-- ~/.config/nvim/lua/config/autocmds.lua
-- Global autocommands

-- Create autocommand groups
local augroup = vim.api.nvim_create_augroup
local autocmd = vim.api.nvim_create_autocmd

-- General settings group
local general_group = augroup("GeneralSettings", { clear = true })

-- Remove trailing whitespace on save
autocmd("BufWritePre", {
  group = general_group,
  pattern = "*",
  callback = function()
    local save_cursor = vim.fn.getpos(".")
    vim.cmd([[%s/\s\+$//e]])
    vim.fn.setpos(".", save_cursor)
  end,
})

-- Terminal handling
autocmd("BufEnter", {
  pattern = "term://*",
  command = "startinsert",
})

autocmd("BufLeave", {
  pattern = "term://*",
  command = "stopinsert",
})

-- Disable auto-commenting on new lines
autocmd("FileType", {
  group = general_group,
  pattern = "*",
  callback = function()
    vim.opt_local.formatoptions:remove({ "c", "r", "o" })
  end,
})

-- Enable spelling for certain file types
autocmd("FileType", {
  group = general_group,
  pattern = { "markdown", "text", "tex", "latex" },
  callback = function()
    vim.opt_local.spell = true
    vim.opt_local.spelllang = "en_us"
  end,
})

-- Set custom comment color
autocmd("ColorScheme", {
  group = general_group,
  callback = function()
    vim.api.nvim_set_hl(0, "Comment", { fg = "#5f87af", bg = "NONE" })
  end,
})

-- LaTeX settings group
local latex_group = augroup("LaTeXSettings", { clear = true })

-- VimTeX omnifunc
autocmd("FileType", {
  group = latex_group,
  pattern = "tex",
  callback = function()
    vim.bo.omnifunc = 'vimtex#complete#omnifunc'
  end,
})

-- SystemVerilog settings group
local sv_group = augroup("SystemVerilog", { clear = true })

-- Load SystemVerilog snippets
autocmd("FileType", {
  pattern = "systemverilog",
  group = sv_group,
  callback = function()
    require("luasnip.loaders.from_lua").load({paths = vim.fn.stdpath('config') .. "/snippets/sv/"})
  end,
})

-- Handle diagnostic updates on tab switching for SystemVerilog files
local tab_switching = false

autocmd("TabLeave", {
  group = sv_group,
  callback = function()
    tab_switching = true
  end,
})

autocmd("BufEnter", {
  group = sv_group,
  pattern = {"*.sv", "*.v"},
  callback = function()
    if tab_switching then
      -- Ignore diagnostic updates on tab switch
      tab_switching = false
    else
      -- Perform diagnostic updates
      vim.diagnostic.show()
      -- We'll move this function to the utils module later
      -- require("utils").refresh_diagnostics()
    end
  end,
})

-- Filetype detection
autocmd({"BufRead", "BufNewFile"}, {
  pattern = "*.sv,*.svh",
  command = "set filetype=systemverilog",
})

-- Reload plugins when plugins.lua is saved
vim.cmd([[
  augroup packer_user_config
    autocmd!
    autocmd BufWritePost plugins/*.lua source <afile>
  augroup end
]])


==================================================
File: lua/config/options.lua
==================================================

-- ~/.config/nvim/lua/config/options.lua
-- Global Vim options

local opt = vim.opt

-- Indentation and tabs
opt.expandtab = true        -- Use spaces instead of tabs
opt.shiftwidth = 2          -- Number of spaces for each indentation
opt.tabstop = 2             -- Number of spaces a tab counts for
opt.softtabstop = 2         -- Number of spaces a tab counts for when editing
opt.smartindent = true      -- Insert indents automatically
opt.autoindent = true       -- Copy indent from current line when starting a new line

-- Line display
opt.number = true           -- Show line numbers
opt.relativenumber = true   -- Show relative line numbers
opt.cursorline = true       -- Highlight current line
opt.wrap = true             -- Wrap lines
opt.linebreak = true        -- Break lines at word boundaries
opt.showmode = false        -- Don't show mode in command line (statusline shows it)
opt.ruler = true            -- Show cursor position

-- Search settings
opt.hlsearch = true         -- Highlight search matches
opt.incsearch = false       -- Don't show partial matches as you type
opt.ignorecase = true       -- Ignore case in search patterns
opt.smartcase = true        -- Override ignorecase when search contains uppercase

-- Window splitting
opt.splitbelow = true       -- Open new horizontal splits below current buffer
opt.splitright = true       -- Open new vertical splits to the right of current buffer

-- User interface
opt.mouse = 'a'             -- Enable mouse for all modes
opt.pumheight = 10          -- Max height of popup menu
opt.showtabline = 2         -- Always show tabline
opt.scrolloff = 5           -- Keep 5 lines above/below cursor visible
opt.sidescrolloff = 5       -- Keep 5 columns left/right of cursor visible

-- Folds
opt.foldenable = true       -- Enable folding
opt.foldmethod = "marker"   -- Use markers for folding

-- File handling
opt.autowriteall = true     -- Automatically save before commands like :next
opt.backup = false          -- Don't create backup files
opt.swapfile = false        -- Don't create swap files
opt.undofile = true         -- Persist undo history across sessions
opt.undolevels = 10000      -- Maximum number of changes that can be undone

-- Clipboard
opt.clipboard = 'unnamedplus' -- Use system clipboard

-- Characters and encodings
opt.fileencoding = "utf-8"  -- Use UTF-8 for file encoding
opt.encoding = "utf-8"      -- Use UTF-8 for vim encoding

-- Terminal options
opt.termguicolors = true    -- Enable 24-bit RGB colors

-- Python provider
vim.g.python3_host_prog = '/usr/bin/python3'

-- Add command to reload config
vim.api.nvim_create_user_command('ReloadConfig', function()
  vim.cmd('source ' .. vim.env.MYVIMRC)
  print('Configuration reloaded!')
end, {})


==================================================
File: lua/config/lazy.lua
==================================================

-- ~/.config/nvim/lua/config/lazy.lua
-- Bootstrap and configure lazy.nvim

-- Bootstrap lazy.nvim
local lazypath = vim.fn.stdpath("data") .. "/lazy/lazy.nvim"
if not (vim.uv or vim.loop).fs_stat(lazypath) then
  local lazyrepo = "https://github.com/folke/lazy.nvim.git"
  local out = vim.fn.system({
    "git",
    "clone",
    "--filter=blob:none",
    "--branch=stable",
    lazyrepo,
    lazypath,
  })
  if vim.v.shell_error ~= 0 then
    vim.api.nvim_echo({
      { "Failed to clone lazy.nvim:\n", "ErrorMsg" },
      { out, "WarningMsg" },
      { "\nPress any key to exit..." },
    }, true, {})
    vim.fn.getchar()
    os.exit(1)
  end
end
vim.opt.rtp:prepend(lazypath)

-- Configure lazy.nvim
require("lazy").setup({
  spec = {
    -- Import plugin specifications from separate files
    { import = "plugins.ui" },     -- UI-related plugins
    { import = "plugins.editor" }, -- Editor enhancement plugins
    { import = "plugins.coding" }, -- Coding-related plugins
    { import = "plugins.lsp" },    -- LSP configurations
    { import = "plugins.tex" },    -- LaTeX tools
    { import = "plugins.tools" },  -- Utilities and tools
  },
  defaults = {
    lazy = false,                  -- Load plugins on startup by default
    version = false,               -- Use latest git commit by default
  },
  install = {
    colorscheme = { "gruvbox-material" }, -- Colorscheme to use during installation
  },
  checker = {
    enabled = true,                -- Check for plugin updates
    frequency = 3600,              -- Check once per hour
  },
  change_detection = {
    enabled = true,                -- Auto-reload config on changes
    notify = false,                -- Don't show notifications on changes
  },
  performance = {
    rtp = {
      disabled_plugins = {
        "gzip",
        "matchit",
        "matchparen",
        "netrwPlugin",
        "tarPlugin",
        "tohtml",
        "tutor",
        "zipPlugin",
      },
    },
  },
})


==================================================
File: lua/config/.svls.toml
==================================================

[options]
# SystemVerilog file extensions
fileExtensions = ["*.sv", "*.svh", "*.v", "*.vh"]

# Parser settings
[parser]
# Enable parsing of all relevant constructs
parseClassProperties = true
parseCovergroups = true
parseAssertions = true
parseConstraints = true

# Type hierarchy settings
[typeHierarchy]
enabled = true
depth = 3

# Include paths for standard libraries and UVM
[libraries]
# Add paths to any standard libraries you use
paths = [
    # Example UVM path (uncomment and modify as needed)
    # "/path/to/uvm/src"
]

# Preprocessor defines
[defines]
# Add any necessary defines here
values = []

# Workspace settings
[workspace]
# Library files or packages to include
libraryFiles = []
# Files to exclude
excludePatterns = ["**/sim/**", "**/tb/**"]
      

==================================================
File: lua/utils/.svls.toml
==================================================

[options]
# SystemVerilog file extensions
fileExtensions = ["*.sv", "*.svh", "*.v", "*.vh"]

# Parser settings
[parser]
# Enable parsing of all relevant constructs
parseClassProperties = true
parseCovergroups = true
parseAssertions = true
parseConstraints = true

# Type hierarchy settings
[typeHierarchy]
enabled = true
depth = 3

# Include paths for standard libraries and UVM
[libraries]
# Add paths to any standard libraries you use
paths = [
    # Example UVM path (uncomment and modify as needed)
    # "/path/to/uvm/src"
]

# Preprocessor defines
[defines]
# Add any necessary defines here
values = []

# Workspace settings
[workspace]
# Library files or packages to include
libraryFiles = []
# Files to exclude
excludePatterns = ["**/sim/**", "**/tb/**"]
            

==================================================
File: lua/utils/functions.lua
==================================================

-- ~/.config/nvim/lua/utils/functions.lua
-- General helper functions

local M = {}

-- Helper function to check if a file exists
M.file_exists = function(file)
  local f = io.open(file, "rb")
  if f then f:close() end
  return f ~= nil
end

-- Helper function to get the content of a file
M.read_file = function(file)
  if not M.file_exists(file) then return nil end
  local f = io.open(file, "rb")
  local content = f:read("*all")
  f:close()
  return content
end

-- Helper function to write to a file
M.write_file = function(file, content)
  local f = io.open(file, "w")
  if not f then return false end
  f:write(content)
  f:close()
  return true
end

-- Helper function to find the root directory of a project
M.find_project_root = function(markers)
  markers = markers or {'.git', '.root', 'Makefile', 'package.json'}

  local current_path = vim.fn.expand('%:p:h')
  local path = current_path

  -- From the current directory, search upwards for a project marker
  while path ~= '/' do
    for _, marker in ipairs(markers) do
      if vim.fn.filereadable(path .. '/' .. marker) == 1 or
         vim.fn.isdirectory(path .. '/' .. marker) == 1 then
        return path
      end
    end
    path = vim.fn.fnamemodify(path, ':h')
  end

  -- If no root is found, return the current directory
  return current_path
end

-- Function to open a floating window with a file
M.open_in_float = function(file, opts)
  opts = opts or {}
  local width = opts.width or 0.8
  local height = opts.height or 0.8

  -- Calculate dimensions
  local win_width = math.floor(vim.o.columns * width)
  local win_height = math.floor(vim.o.lines * height)
  local row = math.floor((vim.o.lines - win_height) / 2)
  local col = math.floor((vim.o.columns - win_width) / 2)

  -- Create a buffer and window
  local buf = vim.api.nvim_create_buf(false, true)

  -- Set buffer options
  if opts.filetype then
    vim.api.nvim_buf_set_option(buf, 'filetype', opts.filetype)
  end

  -- If file exists, read its content
  if file and M.file_exists(file) then
    local content = M.read_file(file)
    if content then
      content = vim.split(content, '\n')
      vim.api.nvim_buf_set_lines(buf, 0, -1, false, content)
    end
  end

  -- Create the window
  local win = vim.api.nvim_open_win(buf, true, {
    relative = 'editor',
    width = win_width,
    height = win_height,
    row = row,
    col = col,
    style = 'minimal',
    border = 'rounded',
  })

  -- Set window options
  if opts.title then
    vim.api.nvim_win_set_option(win, 'winblend', 0)
    vim.api.nvim_win_set_option(win, 'title', opts.title)
    vim.api.nvim_win_set_option(win, 'titlelen', string.len(opts.title) + 10)
  end

  -- Return buffer and window IDs
  return buf, win
end

-- Function to center a string for title display
M.center = function(str)
  local width = vim.api.nvim_get_option("columns")
  local shift = math.floor(width / 2) - math.floor(string.len(str) / 2)
  return string.rep(' ', shift) .. str
end

-- Function to right-justify a string
M.right_justify = function(str)
  local width = vim.api.nvim_get_option("columns")
  local shift = width - string.len(str)
  return string.rep(' ', shift) .. str
end

-- Function to create directory if it doesn't exist
M.ensure_directory = function(path)
  if vim.fn.isdirectory(path) == 0 then
    vim.fn.mkdir(path, "p")
    return true
  end
  return false
end

-- Function to get current timestamp
M.get_timestamp = function(format)
  format = format or "%Y-%m-%d %H:%M:%S"
  return os.date(format)
end

-- Function to sanitize a string for use as a filename
M.sanitize_filename = function(str)
  -- Replace non-alphanumeric characters with underscores
  local sanitized = str:gsub("[^%w%-_.]", "_")
  -- Replace multiple underscores with a single one
  sanitized = sanitized:gsub("_+", "_")
  -- Trim leading/trailing underscores
  sanitized = sanitized:gsub("^_+", ""):gsub("_+$", "")
  return sanitized
end

-- Function to show cheatsheet for current filetype
M.open_cheatsheet = function()
  local filetype = vim.bo.filetype
  local config_path = vim.fn.stdpath('config')
  local cheatsheet_path = string.format("%s/cheatsheets/%s_cheatsheet.md", config_path, filetype)

  if M.file_exists(cheatsheet_path) then
    M.open_in_float(cheatsheet_path, {
      title = filetype:upper() .. " Cheatsheet",
      filetype = "markdown",
      width = 0.9,
      height = 0.9,
    })

    -- Set up keymaps for the cheatsheet window
    local buf = vim.api.nvim_get_current_buf()
    vim.api.nvim_buf_set_keymap(buf, 'n', 'q', ':close<CR>', {noremap = true, silent = true})
  else
    vim.notify(string.format("No cheatsheet found for filetype: %s", filetype), vim.log.levels.WARN)
  end
end

-- Function to open Git cheatsheet
M.git_cheatsheet = function()
  local config_path = vim.fn.stdpath('config')
  local cheatsheet_path = string.format("%s/cheatsheets/git_cheatsheet.md", config_path)

  if M.file_exists(cheatsheet_path) then
    M.open_in_float(cheatsheet_path, {
      title = "Git Cheatsheet",
      filetype = "markdown",
      width = 0.9,
      height = 0.9,
    })

    -- Set up keymaps for the cheatsheet window
    local buf = vim.api.nvim_get_current_buf()
    vim.api.nvim_buf_set_keymap(buf, 'n', 'q', ':close<CR>', {noremap = true, silent = true})
  else
    vim.notify("Git cheatsheet not found", vim.log.levels.WARN)
  end
end

-- Set up the module
function M.setup()
  -- Create commands for cheatsheets
  vim.api.nvim_create_user_command('Cheatsheet', function()
    M.open_cheatsheet()
  end, {})

  vim.api.nvim_create_user_command('GitCheatsheet', function()
    M.git_cheatsheet()
  end, {})

  -- Set up keymaps
  vim.keymap.set('n', '<leader>qq', M.open_cheatsheet,
    {noremap = true, silent = true, desc = "Open filetype cheatsheet"})
  vim.keymap.set('n', '<leader>qg', M.git_cheatsheet,
    {noremap = true, silent = true, desc = "Open Git cheatsheet"})
end

-- Return the module
return M


==================================================
File: lua/utils/init.lua
==================================================

-- ~/.config/nvim/lua/utils/init.lua
-- Utilities loader

-- Load utility modules
local M = {}

-- Setup function to initialize all utilities
function M.setup()
  -- Load dependency check utilities
  require("utils.dependency").check_dependencies()

  -- Load helper functions
  require("utils.functions").setup()

  -- Load diagnostic utilities if in a SystemVerilog file
  if vim.bo.filetype == "systemverilog" or vim.bo.filetype == "verilog" then
    M.refresh_diagnostics()
  end
end

-- Function to check if the current buffer is a SystemVerilog file
M.is_sv_file = function()
  local ft = vim.bo.filetype
  return ft == 'systemverilog' or ft == 'verilog'
end

-- Function to run Verilator diagnostics for SystemVerilog files
M.verilator_diagnostics = function()
  if not M.is_sv_file() then return end

  local bufnr = vim.api.nvim_get_current_buf()
  local filename = vim.api.nvim_buf_get_name(bufnr)
  local cmd = string.format("verilator --lint-only -Wall %s 2>&1", filename)
  local output = vim.fn.system(cmd)
  local diagnostics = {}

  for line in output:gmatch("[^\r\n]+") do
    local lnum, col, type, msg = line:match("(%d+):(%d+):%s*(%w+):%s*(.*)")
    if lnum and col and type and msg then
      table.insert(diagnostics, {
        lnum = tonumber(lnum) - 1,
        col = tonumber(col) - 1,
        severity = type == "Error" and vim.diagnostic.severity.ERROR or vim.diagnostic.severity.WARN,
        message = msg,
        source = "Verilator"
      })
    end
  end

  local namespace = vim.api.nvim_create_namespace("verilator")
  vim.diagnostic.reset(namespace, bufnr)
  vim.diagnostic.set(namespace, bufnr, diagnostics)
end

-- Function to refresh diagnostics
M.refresh_diagnostics = function()
  if not M.is_sv_file() then return end

  local bufnr = vim.api.nvim_get_current_buf()

  local current_diagnostics = vim.diagnostic.get(bufnr)

  if #current_diagnostics == 0 then
    M.verilator_diagnostics()
  end

  current_diagnostics = vim.diagnostic.get(bufnr)

  -- Log diagnostics to the messages buffer
  for _, diagnostic in ipairs(current_diagnostics) do
    vim.notify(string.format("Line %d: %s", diagnostic.lnum + 1, diagnostic.message))
  end
end

-- Return the module
return M


==================================================
File: lua/utils/dependency.lua
==================================================

-- ~/.config/nvim/lua/utils/dependency.lua
-- Dependency checking utilities

local M = {}

-- Function to check if a command exists
M.check_command = function(command)
  local handle = io.popen('command -v ' .. command .. ' 2>/dev/null')
  local result = handle:read('*a')
  handle:close()
  return result ~= ''
end

-- Function to check a dependency and notify if missing
M.check_dependency = function(name, check_func)
  local ok = check_func()
  if not ok then
    vim.notify('Dependency ' .. name .. ' not found. Some features may not work.', vim.log.levels.WARN)
  end
  return ok
end

-- Check all required dependencies at once
M.check_dependencies = function()
  -- List of dependencies to check
  local dependencies = {
    { name = "git", check = function() return M.check_command('git') end },
    { name = "nodejs", check = function() return M.check_command('node') end },
    { name = "python3", check = function() return M.check_command('python3') end },
    { name = "ripgrep", check = function() return M.check_command('rg') end },
    { name = "xclip", check = function() return M.check_command('xclip') end },
    { name = "zathura", check = function() return M.check_command('zathura') end },
  }

  -- Add SystemVerilog-specific dependencies if working with SV files
  local ft = vim.bo.filetype
  if ft == 'systemverilog' or ft == 'verilog' then
    table.insert(dependencies, {
      name = "verilator",
      check = function() return M.check_command('verilator') end
    })
    table.insert(dependencies, {
      name = "svls",
      check = function() return M.check_command('svls') end
    })
  end

  -- Check each dependency
  local results = {}
  for _, dep in ipairs(dependencies) do
    results[dep.name] = M.check_dependency(dep.name, dep.check)
  end

  return results
end

-- Return the module
return M


==================================================
File: lua/personal/concat.lua
==================================================

-- ~/.config/nvim/lua/personal/concat.lua
-- File concatenation utility

local M = {}

-- Create a Python script for file concatenation
local function create_concat_files_script()
    local script = [[
import os
import argparse

def should_exclude(path, exclude_patterns, include_extensions):
    if include_extensions and not any(path.endswith(ext) for ext in include_extensions):
        return True
    return any(pattern in path for pattern in exclude_patterns)

def concat_files(root_dir, output_file, max_depth, exclude_patterns, include_extensions, max_file_size):
    with open(output_file, 'w', encoding='utf-8') as outfile:
        for root, dirs, files in os.walk(root_dir):
            depth = root[len(root_dir):].count(os.sep)
            if max_depth is not None and depth >= max_depth:
                dirs[:] = []  # Don't go deeper
                continue

            dirs[:] = [d for d in dirs if d not in exclude_patterns]

            for file in files:
                file_path = os.path.join(root, file)
                relative_path = os.path.relpath(file_path, root_dir)

                if should_exclude(file_path, exclude_patterns, include_extensions):
                    continue

                if max_file_size and os.path.getsize(file_path) > max_file_size:
                    print(f"Skipping {file_path}: Exceeds size limit")
                    continue

                try:
                    with open(file_path, 'r', encoding='utf-8') as infile:
                        outfile.write(f"\n\n{'='*50}\n")
                        outfile.write(f"File: {relative_path}\n")
                        outfile.write(f"{'='*50}\n\n")
                        outfile.write(infile.read())
                except Exception as e:
                    print(f"Error reading {file_path}: {str(e)}")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Concatenate files recursively.")
    parser.add_argument("-o", "--output", default="concatenated.txt", help="Output file name")
    parser.add_argument("-d", "--depth", type=int, help="Maximum folder depth")
    parser.add_argument("-i", "--input", default=".", help="Input directory")
    parser.add_argument("-e", "--exclude", nargs="+", default=['.git', 'node_modules'], help="Patterns to exclude")
    parser.add_argument("-x", "--extensions", nargs="+", help="File extensions to include")
    parser.add_argument("-s", "--size", type=int, help="Maximum file size in bytes")

    args = parser.parse_args()

    concat_files(args.input, args.output, args.depth, args.exclude, args.extensions, args.size)
    print(f"Files have been concatenated into {args.output}")
]]
    return script
end

-- Function to concatenate files using the Python script
function M.concat_files(args)
    -- Create a temporary file for the Python script
    local tmp_file = os.tmpname()
    local f = io.open(tmp_file, "w")
    if not f then
        vim.notify("Failed to create temporary file", vim.log.levels.ERROR)
        return
    end

    f:write(create_concat_files_script())
    f:close()

    -- Build the command
    local cmd = string.format("python3 %s %s", tmp_file, args or "")

    -- Run the command asynchronously
    vim.fn.jobstart(cmd, {
        on_stdout = function(_, data)
            if data and data[1] ~= "" then
                vim.schedule(function()
                    vim.api.nvim_echo({{table.concat(data, "\n"), "Normal"}}, true, {})
                end)
            end
        end,
        on_stderr = function(_, data)
            if data and data[1] ~= "" then
                vim.schedule(function()
                    vim.api.nvim_echo({{table.concat(data, "\n"), "ErrorMsg"}}, true, {})
                end)
            end
        end,
        on_exit = function(_, exit_code)
            -- Clean up the temporary file
            os.remove(tmp_file)

            if exit_code == 0 then
                vim.schedule(function()
                    vim.api.nvim_echo({{"Concatenation completed successfully", "Normal"}}, true, {})
                end)
            else
                vim.schedule(function()
                    vim.api.nvim_echo({{"Concatenation failed with exit code: " .. exit_code, "ErrorMsg"}}, true, {})
                end)
            end
        end,
    })
end

-- Setup function
function M.setup()
    -- Create a command to use the function
    vim.api.nvim_create_user_command('ConcatFiles', function(opts)
        M.concat_files(opts.args)
    end, {nargs = '*'})

    -- Create a key mapping for the command
    vim.keymap.set('n', '<leader>cf', ':ConcatFiles ',
        {noremap = true, silent = false, desc = "Concatenate files (provide arguments)"})
end

-- Return the module
return M


==================================================
File: lua/personal/transient.lua
==================================================

-- ~/.config/nvim/lua/personal/transient.lua
-- Transient notes system

local M = {}

-- Default configuration
M.config = {
    persistent_buffer_name = "PersistentNotes",
    temporary_buffer_name = "TemporaryNotes",
    random_buffer_name = "RandomNotes",
    file_type = "markdown",
    auto_save = true,
    auto_save_interval = 300, -- 5 minutes
    width = 0.5,  -- 50% of screen width
    height = 0.5, -- 50% of screen height
    notes_dir = vim.fn.expand('~/.local/share/nvim/transient_notes/'), -- Default directory for notes
    random_notes_dir = vim.fn.stdpath('data') .. '/random_notes/', -- Directory for random notes
}

-- Get helper functions
local utils = require("utils.functions")

-- Get the current project name (based on the current working directory)
local function get_project_name()
    local cwd = vim.fn.getcwd()
    return vim.fn.fnamemodify(cwd, ':t')
end

-- Get the full path for the persistent notes file for the current project
local function get_persistent_notes_path()
    local project_name = get_project_name()
    return M.config.notes_dir .. project_name .. '_notes.md'
end

-- Load persisted content from file
function M.load_persisted_content()
    local file_path = get_persistent_notes_path()
    local content = utils.read_file(file_path)
    if content then
        return vim.split(content, "\n")
    end
    return nil
end

-- New function for random notes
function M.open_random_note()
    local random_note_path = M.config.random_notes_dir .. os.date("%Y%m%d%H%M%S") .. ".md"

    -- Ensure the random notes directory exists
    utils.ensure_directory(M.config.random_notes_dir)

    -- Create a new buffer for the random note
    local buf = vim.api.nvim_create_buf(false, true)
    vim.api.nvim_buf_set_name(buf, random_note_path)
    vim.api.nvim_buf_set_option(buf, 'filetype', M.config.file_type)

    -- Calculate dimensions
    local width = math.floor(vim.o.columns * M.config.width)
    local height = math.floor(vim.o.lines * M.config.height)
    local col = math.floor((vim.o.columns - width) / 2)
    local row = math.floor((vim.o.lines - height) / 2)

    -- Open the buffer in a popup window
    local win = vim.api.nvim_open_win(buf, true, {
        relative = 'editor',
        width = width,
        height = height,
        col = col,
        row = row,
        style = 'minimal',
        border = 'rounded'
    })

    -- Set window options
    vim.api.nvim_win_set_option(win, 'winblend', 15)
    vim.api.nvim_win_set_option(win, 'cursorline', true)

    -- Set buffer options
    vim.api.nvim_buf_set_option(buf, 'modifiable', true)
    vim.api.nvim_buf_set_option(buf, 'buftype', '')  -- Allow saving
    vim.api.nvim_buf_set_option(buf, 'bufhidden', 'hide')

    -- Add a title and timestamp
    local title = utils.center("Random Note")
    local timestamp = utils.right_justify(os.date("%Y-%m-%d %H:%M:%S"))
    vim.api.nvim_buf_set_lines(buf, 0, -1, false, {title, timestamp, "", ""})
    vim.api.nvim_buf_add_highlight(buf, -1, 'Title', 0, 0, -1)
    vim.api.nvim_buf_add_highlight(buf, -1, 'Comment', 1, 0, -1)

    -- Set up autocommand to save the random note on buffer write
    vim.cmd(string.format([[
        augroup RandomNoteSave
            autocmd!
            autocmd BufWritePost <buffer=%d> silent! write %s
        augroup END
    ]], buf, random_note_path))
end

-- Save the persistent buffer content to a file
function M.save_persistent_buffer()
    local buf = vim.fn.bufnr(M.config.persistent_buffer_name)
    if buf ~= -1 then
        local lines = vim.api.nvim_buf_get_lines(buf, 0, -1, false)
        local file_path = get_persistent_notes_path()
        if utils.write_file(file_path, table.concat(lines, "\n")) then
            vim.notify("Persistent notes saved to " .. file_path)
        else
            vim.notify("Error: Could not save persistent notes.", vim.log.levels.ERROR)
        end
    end
end

-- Open a notes buffer (persistent or temporary)
function M.open_notes_buffer(persistent)
    local buffer_name = persistent and M.config.persistent_buffer_name or M.config.temporary_buffer_name
    local file_path = persistent and get_persistent_notes_path() or buffer_name

    -- Check if a buffer with this file path already exists
    local buf = vim.fn.bufnr(file_path)

    if buf == -1 or not vim.api.nvim_buf_is_valid(buf) then
        -- If the buffer doesn't exist or is invalid, create a new one
        buf = vim.api.nvim_create_buf(false, true)
        vim.api.nvim_buf_set_name(buf, file_path)
        vim.api.nvim_buf_set_option(buf, 'filetype', M.config.file_type)

        -- Load persisted content if it's the persistent buffer
        if persistent then
            local content = M.load_persisted_content()
            if content then
                vim.api.nvim_buf_set_lines(buf, 0, -1, false, content)
            end
            -- Set the buffer as unmodified after loading content
            vim.api.nvim_buf_set_option(buf, 'modified', false)
        end
    end

    -- Calculate dimensions
    local width = math.floor(vim.o.columns * M.config.width)
    local height = math.floor(vim.o.lines * M.config.height)
    local col = math.floor((vim.o.columns - width) / 2)
    local row = math.floor((vim.o.lines - height) / 2)

    -- Open the buffer in a popup window
    local win = vim.api.nvim_open_win(buf, true, {
        relative = 'editor',
        width = width,
        height = height,
        col = col,
        row = row,
        style = 'minimal',
        border = 'rounded'
    })

    -- Set window options
    vim.api.nvim_win_set_option(win, 'winblend', 15)
    vim.api.nvim_win_set_option(win, 'cursorline', true)

    -- Set buffer options
    vim.api.nvim_buf_set_option(buf, 'modifiable', true)
    vim.api.nvim_buf_set_option(buf, 'buftype', '')  -- Allow saving
    vim.api.nvim_buf_set_option(buf, 'bufhidden', 'hide')

    -- Add a title and timestamp if the buffer is empty
    if vim.api.nvim_buf_line_count(buf) == 1 and vim.api.nvim_buf_get_lines(buf, 0, -1, false)[1] == "" then
        local title = utils.center(persistent and "Persistent Notes (" .. get_project_name() .. ")" or "Temporary Notes")
        local timestamp = utils.right_justify(os.date("%Y-%m-%d %H:%M:%S"))
        local file_info = persistent and ("File: " .. file_path) or "Temporary buffer (not saved)"
        vim.api.nvim_buf_set_lines(buf, 0, -1, false, {title, timestamp, file_info, ""})
        vim.api.nvim_buf_add_highlight(buf, -1, 'Title', 0, 0, -1)
        vim.api.nvim_buf_add_highlight(buf, -1, 'Comment', 1, 0, -1)
        vim.api.nvim_buf_add_highlight(buf, -1, 'Comment', 2, 0, -1)
    end
end

-- New function to grep random notes using Telescope
function M.grep_random_notes()
    local ok, telescope = pcall(require, 'telescope.builtin')
    if not ok then
        vim.notify("Telescope is not installed. Please install telescope.nvim to use this feature.", vim.log.levels.ERROR)
        return
    end

    telescope.live_grep({
        prompt_title = "Search Random Notes",
        search_dirs = {M.config.random_notes_dir},
        path_display = {"smart"},
    })
end

-- Global search functionality
function M.global_search_notes()
    local search_term = vim.fn.input("Search for: ")
    if search_term == "" then return end

    local results = {}
    local files = vim.fn.glob(M.config.notes_dir .. '*_notes.md', 0, 1)
    for _, file in ipairs(files) do
        local content = utils.read_file(file)
        if content then
            for line in content:gmatch("[^\r\n]+") do
                if line:lower():find(search_term:lower(), 1, true) then
                    table.insert(results, {filename = file, line = line})
                end
            end
        end
    end

    if #results == 0 then
        vim.notify("No results found.")
        return
    end

    -- Create a new buffer for search results
    local buf = vim.api.nvim_create_buf(false, true)
    vim.api.nvim_buf_set_option(buf, 'buftype', 'nofile')
    vim.api.nvim_buf_set_option(buf, 'bufhidden', 'wipe')
    vim.api.nvim_buf_set_option(buf, 'swapfile', false)
    vim.api.nvim_buf_set_name(buf, "Search Results")

    -- Populate the buffer with search results
    local lines = {"Search results for: " .. search_term, ""}
    for _, result in ipairs(results) do
        table.insert(lines, result.filename .. ":")
        table.insert(lines, "    " .. result.line)
        table.insert(lines, "")
    end
    vim.api.nvim_buf_set_lines(buf, 0, -1, false, lines)

    -- Open the buffer in a new window
    vim.cmd('split')
    vim.api.nvim_win_set_buf(0, buf)
end

-- Clipboard integration
function M.copy_to_clipboard()
    local buf = vim.api.nvim_get_current_buf()
    local start_line, end_line

    if vim.fn.mode() == 'v' or vim.fn.mode() == 'V' then
        start_line = vim.fn.line("'<")
        end_line = vim.fn.line("'>")
    else
        start_line = 1
        end_line = -1
    end

    local lines = vim.api.nvim_buf_get_lines(buf, start_line - 1, end_line, false)
    local content = table.concat(lines, "\n")
    vim.fn.setreg('+', content)
    vim.notify("Copied to clipboard.")
end

-- Setup function
function M.setup(opts)
    -- Merge user options with defaults
    M.config = vim.tbl_deep_extend("force", M.config, opts or {})

    -- Ensure the notes directories exist
    utils.ensure_directory(M.config.notes_dir)
    utils.ensure_directory(M.config.random_notes_dir)

    -- Create commands
    vim.api.nvim_create_user_command('PersistentNotes', function()
        M.open_notes_buffer(true)
    end, {})

    vim.api.nvim_create_user_command('TemporaryNotes', function()
        M.open_notes_buffer(false)
    end, {})

    vim.api.nvim_create_user_command('RandomNote', function()
        M.open_random_note()
    end, {})

    vim.api.nvim_create_user_command('SavePersistentNotes', function()
        M.save_persistent_buffer()
    end, {})

    vim.api.nvim_create_user_command('SearchNotes', function()
        M.global_search_notes()
    end, {})

    vim.api.nvim_create_user_command('CopyNotesToClipboard', function()
        M.copy_to_clipboard()
    end, {})

    vim.api.nvim_create_user_command('GrepRandomNotes', function()
        M.grep_random_notes()
    end, {})

    -- Set up auto-save for persistent notes if enabled
    if M.config.auto_save then
        vim.fn.timer_start(M.config.auto_save_interval * 1000, function()
            M.save_persistent_buffer()
        end, {["repeat"] = -1})
    end

    -- Set up keybindings
    vim.keymap.set('n', '<leader>pn', ':PersistentNotes<CR>',
        {noremap = true, silent = true, desc = "Open persistent notes"})
    vim.keymap.set('n', '<leader>tn', ':TemporaryNotes<CR>',
        {noremap = true, silent = true, desc = "Open temporary notes"})
    vim.keymap.set('n', '<leader>rn', ':RandomNote<CR>',
        {noremap = true, silent = true, desc = "Create random note"})
    vim.keymap.set('n', '<leader>ns', ':SearchNotes<CR>',
        {noremap = true, silent = true, desc = "Search notes"})
    vim.keymap.set('n', '<leader>nc', ':CopyNotesToClipboard<CR>',
        {noremap = true, silent = true, desc = "Copy notes to clipboard"})
    vim.keymap.set('v', '<leader>nc', ':CopyNotesToClipboard<CR>',
        {noremap = true, silent = true, desc = "Copy selected notes to clipboard"})
    vim.keymap.set('n', '<leader>ng', ':GrepRandomNotes<CR>',
        {noremap = true, silent = true, desc = "Grep random notes"})

    -- Enable syntax highlighting for markdown in the notes buffers
    vim.cmd([[
        augroup TransientNotesSyntax
            autocmd!
            autocmd FileType markdown setlocal syntax=markdown
        augroup END
    ]])

    -- Add autocommand to save persistent notes on buffer write
    vim.cmd([[
        augroup PersistentNotesSave
            autocmd!
            autocmd BufWritePost PersistentNotes lua require('personal.transient').save_persistent_buffer()
        augroup END
    ]])
end

-- Return the module
return M


==================================================
File: lua/personal/checklist.lua
==================================================

-- ~/.config/nvim/lua/personal/checklist.lua
-- Checklist functionality

local M = {}

-- Configuration
M.config = {
  debug = false,
  checklist_dir = vim.fn.stdpath('config') .. "/checklists",
  pdf_dir = vim.fn.stdpath('config') .. '/books',
  pdf_viewer = 'zathura',
}

-- Helper function for debug printing
local function debug_print(message)
  if M.config.debug then
    vim.notify(message, vim.log.levels.DEBUG)
  end
end

-- Function to save the current buffer to file
local function save_buffer_to_file()
  local bufnr = vim.api.nvim_get_current_buf()
  local filepath = vim.api.nvim_buf_get_name(bufnr)
  local lines = vim.api.nvim_buf_get_lines(bufnr, 0, -1, false)

  local f = io.open(filepath, "w")
  if f then
    f:write(table.concat(lines, "\n"))
    f:close()
    debug_print("Saved changes to " .. filepath)
    return true
  else
    vim.notify("Failed to write to file: " .. filepath, vim.log.levels.ERROR)
    return false
  end
end

-- Function to parse markdown and extract page offset
local function parse_markdown_and_get_offset(markdown_path)
  local page_offset = 0

  local f = io.open(markdown_path, "r")
  if not f then
    debug_print("Failed to open file: " .. markdown_path)
    return page_offset
  end

  for line in f:lines() do
    local offset = line:match('^Page Offset: (.+)$')
    if offset then
      page_offset = tonumber(offset) or 0
      break
    end
  end

  f:close()
  debug_print("Extracted page offset: " .. page_offset)
  return page_offset
end

-- Function to create a floating window
local function create_float()
  local width = math.floor(vim.o.columns * 0.8)
  local height = math.floor(vim.o.lines * 0.8)
  local win_id = vim.api.nvim_open_win(0, true, {
    relative = 'editor',
    width = width,
    height = height,
    col = math.floor((vim.o.columns - width) / 2),
    row = math.floor((vim.o.lines - height) / 2),
    style = 'minimal',
    border = 'rounded',
  })
  return win_id
end

-- Function to safely edit a file, handling swap files
local function safe_edit(file_path)
  local ok, err = pcall(vim.cmd, "edit " .. file_path)
  if not ok then
    if err:match("E325") then
      -- Swap file exists, ask user what to do
      vim.notify("Swap file exists for " .. file_path)
      local choice = vim.fn.input("(E)dit anyway, (R)ecover, (Q)uit: ")
      if choice:lower() == "e" then
        vim.cmd("edit! " .. file_path)
      elseif choice:lower() == "r" then
        vim.cmd("recover " .. file_path)
      else
        vim.notify("Aborted opening the checklist.")
        return false
      end
    else
      -- Some other error occurred
      vim.notify("Error opening file: " .. err, vim.log.levels.ERROR)
      return false
    end
  end
  return true
end

-- Function to display checklist in a floating window
local function display_checklist(markdown_path)
  local bufnr = vim.fn.bufnr(markdown_path)
  local win_id = create_float()

  if bufnr == -1 then
    -- If the buffer doesn't exist, create it
    if not safe_edit(markdown_path) then
      return nil, nil
    end
    bufnr = vim.fn.bufnr(markdown_path)
  else
    -- If the buffer exists, set it as the current buffer for the new window
    vim.api.nvim_win_set_buf(win_id, bufnr)
  end

  -- Ensure the buffer is loaded
  if not vim.api.nvim_buf_is_loaded(bufnr) then
    vim.api.nvim_buf_set_option(bufnr, 'buftype', '')
    vim.api.nvim_command('buffer ' .. bufnr)
  end

  -- Set up keybindings for the floating window
  local opts = { noremap = true, silent = true }
  vim.api.nvim_buf_set_keymap(bufnr, 'n', '<CR>', ':lua require("personal.checklist").toggle_item()<CR>', opts)
  vim.api.nvim_buf_set_keymap(bufnr, 'n', 'q', ':q<CR>', opts)
  vim.api.nvim_buf_set_keymap(bufnr, 'n', '<leader>p', ':lua require("personal.checklist").open_pdf()<CR>', opts)

  -- Set filetype to markdown
  vim.api.nvim_buf_set_option(bufnr, 'filetype', 'markdown')

  return bufnr, win_id
end

-- Function to toggle checklist items
function M.toggle_item()
  local line = vim.api.nvim_get_current_line()
  local new_line

  if line:match('^%s*- %[ %]') then
    new_line = line:gsub('^(%s*- )%[ %]', '%1[x]')
  elseif line:match('^%s*- %[x%]') then
    new_line = line:gsub('^(%s*- )%[x%]', '%1[ ]')
  end

  if new_line then
    vim.api.nvim_set_current_line(new_line)
    save_buffer_to_file()
  end
end

-- Function to save the checklist
function M.save_checklist()
  save_buffer_to_file()
  vim.api.nvim_command('setlocal nomodified')
end

-- Function to close the checklist
function M.close_checklist()
  save_buffer_to_file()
  vim.api.nvim_command('q')
end

-- Function to open PDF at the correct page
function M.open_pdf()
  local markdown_path = vim.api.nvim_buf_get_name(0)
  local pdf_name = vim.fn.fnamemodify(markdown_path, ':t:r') .. '.pdf'
  local pdf_path = M.config.pdf_dir .. '/' .. pdf_name

  -- Check if the PDF file exists
  if vim.fn.filereadable(pdf_path) == 0 then
    vim.notify("Error: PDF file not found: " .. pdf_path, vim.log.levels.ERROR)
    return
  end

  -- Get current line number
  local current_line = vim.api.nvim_win_get_cursor(0)[1]

  -- Parse the markdown file to get the page offset
  local page_offset = parse_markdown_and_get_offset(markdown_path)

  -- Find the nearest previous line with a page number
  local page_number = 1
  for i = current_line, 1, -1 do
    local line = vim.api.nvim_buf_get_lines(0, i-1, i, false)[1]
    local found_page = line:match("%(Page (%d+)%)")
    if found_page then
      page_number = tonumber(found_page)
      break
    end
  end

  -- Apply the page offset
  local adjusted_page = page_number + page_offset

  debug_print("Opening PDF: " .. pdf_path .. " at page " .. adjusted_page)
  vim.fn.system(M.config.pdf_viewer .. ' --page=' .. adjusted_page .. ' "' .. pdf_path .. '" &')
end

-- Function to list and select checklists
function M.list_checklists()
  local checklists = vim.fn.globpath(M.config.checklist_dir, '*.md', false, true)

  if #checklists == 0 then
    vim.notify("No checklists found in " .. M.config.checklist_dir, vim.log.levels.WARN)
    return
  end

  vim.ui.select(checklists, {
    prompt = 'Select a checklist:',
    format_item = function(item)
      return vim.fn.fnamemodify(item, ':t:r')
    end,
  }, function(choice)
    if choice then
      display_checklist(choice)
    end
  end)
end

-- Function to generate directory structure from a checklist
function M.generate_directory_structure()
  -- Ask the user to select a checklist
  local checklists = vim.fn.globpath(M.config.checklist_dir, '*.md', false, true)

  if #checklists == 0 then
    vim.notify("No checklists found in " .. M.config.checklist_dir, vim.log.levels.WARN)
    return
  end

  vim.ui.select(checklists, {
    prompt = 'Select a checklist to generate directory structure:',
    format_item = function(item)
      return vim.fn.fnamemodify(item, ':t:r')
    end,
  }, function(checklist_path)
    if not checklist_path then return end

    -- Get project name from checklist filename
    local project_name = vim.fn.fnamemodify(checklist_path, ':t:r')

    -- Ask for projects directory
    local projects_dir = vim.fn.input("Projects directory: ", vim.fn.expand('~/projects'), "dir")
    if projects_dir == "" then return end

    -- Create the base project directory
    local base_path = projects_dir .. '/' .. project_name
    if vim.fn.isdirectory(base_path) == 1 then
      local choice = vim.fn.input("Project directory already exists. Overwrite? [y/N] ")
      if choice:lower() ~= "y" then
        vim.notify("Operation cancelled.")
        return
      end
    end

    vim.fn.mkdir(base_path, "p")

    -- Helper function to sanitize folder names
    local function sanitize_name(name)
      return name:gsub("%s+", "_"):gsub("[^%w_-]", "")
    end

    -- Read the checklist file
    local f = io.open(checklist_path, "r")
    if not f then
      vim.notify("Failed to open checklist file: " .. checklist_path, vim.log.levels.ERROR)
      return
    end

    local current_chapter = nil

    for line in f:lines() do
      if line:match("^%- %[.?%] %*%*Chapter %d+:") then
        -- Chapter line
        local chapter_name = line:match("%*%*(.-)%*%*")
        current_chapter = sanitize_name(chapter_name)
        local chapter_path = base_path .. "/" .. current_chapter
        vim.fn.mkdir(chapter_path, "p")

        -- Create subfolders
        vim.fn.mkdir(chapter_path .. "/concepts", "p")
        vim.fn.mkdir(chapter_path .. "/examples", "p")
        vim.fn.mkdir(chapter_path .. "/exercises", "p")
      elseif line:match("^%s+%- %[.?%] %d+%.%d+") and current_chapter then
        -- Section line
        local section_name = line:match("%d+%.%d+%s+(.-) %(")
        if section_name then
          local section_path = base_path .. "/" .. current_chapter .. "/concepts/" .. sanitize_name(section_name)
          vim.fn.mkdir(section_path, "p")
        end
      end
    end

    f:close()

    vim.notify("Folder structure created successfully in '" .. base_path .. "'")
  end)
end

-- Function to toggle debugging
function M.toggle_debug()
  M.config.debug = not M.config.debug
  vim.notify("Checklist debugging " .. (M.config.debug and "enabled" or "disabled"))
end

-- Setup function
function M.setup()
  -- Ensure the checklist directory exists
  if vim.fn.isdirectory(M.config.checklist_dir) == 0 then
    vim.fn.mkdir(M.config.checklist_dir, "p")
  end

  -- Ensure the PDF directory exists
  if vim.fn.isdirectory(M.config.pdf_dir) == 0 then
    vim.fn.mkdir(M.config.pdf_dir, "p")
  end

  -- Create user commands
  vim.api.nvim_create_user_command('ChecklistOpen', function()
    M.list_checklists()
  end, {})

  vim.api.nvim_create_user_command('ChecklistGenerate', function()
    M.generate_directory_structure()
  end, {})

  vim.api.nvim_create_user_command('ChecklistDebug', function()
    M.toggle_debug()
  end, {})

  -- Set up keymaps
  vim.keymap.set('n', '<leader>cl', M.list_checklists,
    {noremap = true, silent = true, desc = "List checklists"})

  vim.keymap.set('n', '<leader>cg', M.generate_directory_structure,
    {noremap = true, silent = true, desc = "Generate directory structure from checklist"})
end

-- Return the module
return M


==================================================
File: lua/personal/.svls.toml
==================================================

[options]
# SystemVerilog file extensions
fileExtensions = ["*.sv", "*.svh", "*.v", "*.vh"]

# Parser settings
[parser]
# Enable parsing of all relevant constructs
parseClassProperties = true
parseCovergroups = true
parseAssertions = true
parseConstraints = true

# Type hierarchy settings
[typeHierarchy]
enabled = true
depth = 3

# Include paths for standard libraries and UVM
[libraries]
# Add paths to any standard libraries you use
paths = [
    # Example UVM path (uncomment and modify as needed)
    # "/path/to/uvm/src"
]

# Preprocessor defines
[defines]
# Add any necessary defines here
values = []

# Workspace settings
[workspace]
# Library files or packages to include
libraryFiles = []
# Files to exclude
excludePatterns = ["**/sim/**", "**/tb/**"]
            

==================================================
File: lua/personal/spell.lua
==================================================

-- ~/.config/nvim/lua/personal/spell.lua
-- Spell checking utilities

local M = {}

-- Default spellchecking settings
M.config = {
  default_lang = 'en',      -- Default language
  secondary_lang = 'sl',    -- Secondary language (Slovene in this case)
  auto_enable_filetypes = { -- Filetypes to automatically enable spell checking
    'markdown',
    'text',
    'tex',
    'latex',
    'mail',
    'gitcommit',
  },
}

-- Flag to track if Slovene spell checking is enabled
local slovene_spell_enabled = false

-- Function to toggle Slovene spell checking
function M.toggle_slovene_spell()
  if slovene_spell_enabled then
    -- If Slovene spelling is on, turn it off and switch to English
    vim.opt.spelllang:remove('sl')
    vim.opt.spelllang:append('en')
    slovene_spell_enabled = false
    vim.notify("Switched to English spell checking")
  else
    -- If Slovene spelling is off, turn it on and remove English
    vim.opt.spelllang:remove('en')
    vim.opt.spelllang:append('sl')
    slovene_spell_enabled = true
    vim.notify("Switched to Slovene spell checking")
  end
end

-- Function to toggle spell checking
function M.toggle_spell()
  vim.opt.spell = not vim.opt.spell:get()
  vim.notify("Spell checking " .. (vim.opt.spell:get() and "enabled" or "disabled"))
end

-- Function to auto-enable spell checking for specific filetypes
local function setup_auto_spell()
  vim.api.nvim_create_autocmd("FileType", {
    pattern = M.config.auto_enable_filetypes,
    callback = function()
      vim.opt_local.spell = true
      vim.opt_local.spelllang = M.config.default_lang
    end,
  })
end

-- Setup function
function M.setup(opts)
  -- Merge user options with defaults
  M.config = vim.tbl_deep_extend("force", M.config, opts or {})

  -- Set up global defaults
  vim.opt.spelllang = M.config.default_lang

  -- Set up auto spell checking
  setup_auto_spell()

  -- Create user commands
  vim.api.nvim_create_user_command('SpellToggle', function()
    M.toggle_spell()
  end, {})

  vim.api.nvim_create_user_command('SpellSlovene', function()
    M.toggle_slovene_spell()
  end, {})

  -- Set up key mappings
  vim.keymap.set('n', '<leader>zz', M.toggle_spell,
    {noremap = true, silent = true, desc = "Toggle spell checking"})
  vim.keymap.set('n', '<leader>zs', M.toggle_slovene_spell,
    {noremap = true, silent = true, desc = "Toggle Slovene spell checking"})

  -- Spell checking suggestions mappings
  vim.keymap.set('n', '<leader>zn', ']s',
    {noremap = true, silent = true, desc = "Next misspelled word"})
  vim.keymap.set('n', '<leader>zp', '[s',
    {noremap = true, silent = true, desc = "Previous misspelled word"})
  vim.keymap.set('n', '<leader>za', 'zg',
    {noremap = true, silent = true, desc = "Add word to dictionary"})
  vim.keymap.set('n', '<leader>z?', function()
    vim.cmd('normal! z=')
  end, {noremap = true, silent = true, desc = "Show spelling suggestions"})
end

-- Return the module
return M


==================================================
File: lua/personal/luasnip-helper-funcs.lua
==================================================

-- ~/.config/nvim/lua/personal/luasnip-helper-funcs.lua
local ls = require("luasnip")

local M = {}

-- Helper function for working with visual selections
M.get_visual = function(args, parent)
    if (#parent.snippet.env.SELECT_RAW > 0) then
        return ls.snippet_node(nil, {
            ls.insert_node(1, parent.snippet.env.SELECT_RAW)
        })
    else
        return ls.snippet_node(nil, {
            ls.insert_node(1, '')
        })
    end
end

-- Get the current date in ISO format
M.get_ISO_8601_date = function()
    return os.date("%Y-%m-%d")
end

-- Get current filename
M.get_filename = function()
    return vim.fn.expand("%:t")
end

-- Get current filepath
M.get_filepath = function()
    return vim.fn.expand("%:p")
end

return M


==================================================
File: lua/personal/beamer.lua
==================================================

-- ~/.config/nvim/lua/personal/beamer.lua
-- Beamer folding system for LaTeX presentations

local M = {}

-- Function to determine fold level for beamer frames
local function beamer_fold(lnum)
  local line = vim.fn.getline(lnum)

  if line:match("\\begin{frame}") then
    return ">1"  -- Start a fold at level 1
  elseif line:match("\\end{frame}") then
    return "<1"  -- End a fold at level 1
  else
    return "="   -- Keep current fold level
  end
end

-- Function to set up folding for the current buffer
local function setup_folding()
  vim.wo.foldmethod = "expr"
  vim.wo.foldexpr = "v:lua.require'personal.beamer'.fold(v:lnum)"
  vim.wo.foldlevel = 0  -- Close all folds by default
  vim.cmd("normal! zx")  -- Refresh folds
end

-- Expose the fold function for use in foldexpr
function M.fold(lnum)
  return beamer_fold(lnum)
end

-- Setup function
function M.setup()
  -- Create command to manually activate beamer folding
  vim.api.nvim_create_user_command("BeamerFold", function()
    setup_folding()
  end, {})

  -- Auto-setup for TeX files
  vim.api.nvim_create_autocmd({"BufRead", "BufNewFile"}, {
    pattern = "*.tex",
    callback = function()
      -- Check if this is a beamer document
      local content = vim.api.nvim_buf_get_lines(0, 0, 50, false)
      local is_beamer = false

      for _, line in ipairs(content) do
        if line:match("\\documentclass%s*%[?%s*beamer%s*%]?") or line:match("\\begin{frame}") then
          is_beamer = true
          break
        end
      end

      if is_beamer then
        setup_folding()
      end
    end
  })

  -- Map a key to toggle all folds in a beamer document
  vim.keymap.set('n', '<leader>bf', ':BeamerFold<CR>zM',
    {noremap = true, silent = true, desc = "Set up beamer folding and close all folds"})

  -- Map a key to open all folds
  vim.keymap.set('n', '<leader>bo', 'zR',
    {noremap = true, silent = true, desc = "Open all folds"})

  -- Map a key to close all folds
  vim.keymap.set('n', '<leader>bc', 'zM',
    {noremap = true, silent = true, desc = "Close all folds"})
end

-- Return the module
return M


==================================================
File: lua/personal/init.lua
==================================================

-- ~/.config/nvim/lua/personal/init.lua
-- Personal modules loader

local M = {}

-- Helper function to safely require a module
local function safe_require(module_name)
  local ok, module = pcall(require, module_name)
  if not ok then
    vim.notify("Failed to load " .. module_name .. ": " .. tostring(module), vim.log.levels.WARN)
    return nil
  end
  return module
end

-- Function to safely setup a module if it exists
local function safe_setup(module_name, opts)
  local module = safe_require(module_name)
  if module and type(module.setup) == "function" then
    local setup_ok, err = pcall(function()
      if opts then
        module.setup(opts)
      else
        module.setup()
      end
    end)

    if not setup_ok then
      vim.notify("Error setting up " .. module_name .. ": " .. tostring(err), vim.log.levels.ERROR)
    end
  end
end

-- Set up all personal modules
function M.setup()
  -- vim.notify("Setting up personal modules...")

  -- Set up modules with error handling
  safe_setup("personal.transient", {
    width = 0.6,  -- 60% of screen width
    height = 0.7, -- 70% of screen height
    notes_dir = vim.fn.expand('~/Documents/my_notes/'),
  })

  safe_setup("personal.checklist")
  safe_setup("personal.beamer")
  safe_setup("personal.concat")
  safe_setup("personal.spell")

  -- vim.notify("Personal modules setup complete")
end

-- Return the module table (THIS LINE IS CRITICAL)
return M


==================================================
File: .jukit/.jukit_info.json
==================================================

{"terminal": "nvimterm"}

==================================================
File: snippets/.svls.toml
==================================================

[options]
# SystemVerilog file extensions
fileExtensions = ["*.sv", "*.svh", "*.v", "*.vh"]

# Parser settings
[parser]
# Enable parsing of all relevant constructs
parseClassProperties = true
parseCovergroups = true
parseAssertions = true
parseConstraints = true

# Type hierarchy settings
[typeHierarchy]
enabled = true
depth = 3

# Include paths for standard libraries and UVM
[libraries]
# Add paths to any standard libraries you use
paths = [
    # Example UVM path (uncomment and modify as needed)
    # "/path/to/uvm/src"
]

# Preprocessor defines
[defines]
# Add any necessary defines here
values = []

# Workspace settings
[workspace]
# Library files or packages to include
libraryFiles = []
# Files to exclude
excludePatterns = ["**/sim/**", "**/tb/**"]
            

==================================================
File: snippets/sv.lua
==================================================

-- At the beginning of the file
print("Loading SystemVerilog snippets")

-- After loading each file
print("Loaded " .. (non_syn and #non_syn or 0) .. " non-synthesizable snippets")
print("Loaded " .. (syn and #syn or 0) .. " synthesizable snippets")
print("Loaded " .. (uvm and #uvm or 0) .. " UVM snippets")

-- Before returning
print("Returning " .. #snippets .. " total SystemVerilog snippets")local ls = require("luasnip")

-- Define the shorthand functions
local s = ls.snippet
local sn = ls.snippet_node
local t = ls.text_node
local i = ls.insert_node
local f = ls.function_node
local d = ls.dynamic_node
local c = ls.choice_node
local fmt = require("luasnip.extras.fmt").fmt
local fmta = require("luasnip.extras.fmt").fmta
local rep = require("luasnip.extras").rep

-- Helper function to load snippets from a file
local function load_snippets(file)
    local status, snippets = pcall(function()
        -- Create a new environment with the shorthand functions and other necessities
        local env = {
            s = s, sn = sn, t = t, i = i, f = f, d = d, c = c,
            fmt = fmt, fmta = fmta, rep = rep,
            ls = ls,  -- Also pass the entire luasnip module
            vim = vim,  -- Pass vim module for vim.fn calls
            require = require,  -- Include the require function
        }
        -- Set the environment's metatable to fall back to the global environment
        setmetatable(env, {__index = _G})

        local fn = vim.fn
        local config_path = fn.stdpath('config')
        local chunk, err = loadfile(config_path .. "/snippets/sv/" .. file .. ".lua", "t", env)
        if chunk then
            return chunk()
        else
            error(err)
        end
    end)
    if status then
        return snippets
    else
        print("Error loading " .. file .. ".lua: " .. snippets)
        return {}
    end
end

-- Load all snippet files
local non_syn = load_snippets("non_synthesizable")
local syn = load_snippets("synthesizable")
local uvm = load_snippets("uvm")

-- Combine all snippets
local snippets = {}
for _, snip_table in ipairs({syn, non_syn, uvm}) do
    for _, snip in ipairs(snip_table) do
        table.insert(snippets, snip)
    end
end

-- Return the snippets for use by LuaSnip's loader
return snippets


==================================================
File: snippets/tex.lua
==================================================

local ls = require("luasnip")

-- Define the shorthand functions
local s = ls.snippet
local sn = ls.snippet_node
local t = ls.text_node
local i = ls.insert_node
local f = ls.function_node
local d = ls.dynamic_node
local c = ls.choice_node
local fmt = require("luasnip.extras.fmt").fmt
local fmta = require("luasnip.extras.fmt").fmta
local rep = require("luasnip.extras").rep

-- Load helper functions
local helpers = require('personal.luasnip-helper-funcs')
local get_visual = helpers.get_visual

-- Math context detection
local tex = {}
tex.in_mathzone = function() return vim.fn['vimtex#syntax#in_mathzone']() == 1 end
tex.in_text = function() return not tex.in_mathzone() end

-- Helper function to load snippets from a file
local function load_snippets(file)
    local status, snippets = pcall(function()
        -- Create a new environment with the shorthand functions and other necessities
        local env = {
            s = s, sn = sn, t = t, i = i, f = f, d = d, c = c,
            fmt = fmt, fmta = fmta, rep = rep,
            ls = ls,  -- Also pass the entire luasnip module
            vim = vim,  -- Pass vim module for vim.fn calls
            require = require,  -- Include the require function
            get_visual = get_visual,  -- Pass the get_visual function
            tex = tex  -- Pass the tex table with its functions
        }
        -- Set the environment's metatable to fall back to the global environment
        setmetatable(env, {__index = _G})

        -- Load the file in this environment
        local fn = vim.fn
        local config_path = fn.stdpath('config')
        local chunk, err = loadfile(config_path .. "/snippets/tex/" .. file .. ".lua", "t", env)
        if chunk then
            return chunk()
        else
            error(err)
        end
    end)
    if status then
        return snippets
    else
        print("Error loading " .. file .. ".lua: " .. snippets)
        return {}
    end
end

-- Load all snippet files
local delimiter = load_snippets("delimiter")
local environments = load_snippets("environments")
local fonts = load_snippets("fonts")
local greek = load_snippets("greek")
local luatex = load_snippets("luatex")
local math = load_snippets("math")
local static = load_snippets("static")
local system = load_snippets("system")
local test = load_snippets("test")
local tmp = load_snippets("tmp")

-- Combine all snippets
local snippets = {}
for _, snip_table in ipairs({
    delimiter, environments, fonts, greek, luatex,
    math, static, system, test, tmp
}) do
    for _, snip in ipairs(snip_table) do
        table.insert(snippets, snip)
    end
end

-- You can add any additional snippets directly in tex.lua if you want
table.insert(snippets, s("texmain", {
    t("\\documentclass{article}\n\\begin{document}\n\n"),
    i(1),
    t("\n\n\\end{document}")
}))

-- Return the snippets for use by LuaSnip's loader
return snippets


==================================================
File: snippets/all.lua
==================================================

-- ~/.config/nvim/snippets/all.lua
-- Global snippets available in all file types

local ls = require("luasnip")
local s = ls.snippet
local sn = ls.snippet_node
local t = ls.text_node
local i = ls.insert_node
local f = ls.function_node
local c = ls.choice_node
local d = ls.dynamic_node
local fmt = require("luasnip.extras.fmt").fmt
local fmta = require("luasnip.extras.fmt").fmta

-- Helper function to get the current date in ISO format
local function get_ISO_8601_date()
  return os.date("%Y-%m-%d")
end

-- Helper function for working with visual selections
local function get_visual(args, parent)
  if (#parent.snippet.env.SELECT_RAW > 0) then
    return sn(nil, i(1, parent.snippet.env.SELECT_RAW))
  else
    return sn(nil, i(1, ''))
  end
end

-- Snippets
return {
  -- Date insertion
  s("date", {
    f(function() return os.date("%Y-%m-%d") end, {}),
  }),

  -- Date and time insertion
  s("datetime", {
    f(function() return os.date("%Y-%m-%d %H:%M:%S") end, {}),
  }),

  -- Todo comment
  s("todo", fmt("TODO: {} ({})", {
    i(1, "Description"),
    f(get_ISO_8601_date),
  })),

  -- Fixme comment
  s("fixme", fmt("FIXME: {} ({})", {
    i(1, "Description"),
    f(get_ISO_8601_date),
  })),

  -- Note comment
  s("note", fmt("NOTE: {} ({})", {
    i(1, "Description"),
    f(get_ISO_8601_date),
  })),

  -- Simple header box
  s("box", fmt([[
/*
 * {}
 * {}
 */
]], {
    i(1, "Title"),
    i(2, "Description"),
  })),

  -- Markdown header with auto-timestamp
  s("mdheader", fmt([[
# {}

> Created: {}
> Last Updated: {}

{}

]], {
    i(1, "Title"),
    f(get_ISO_8601_date),
    f(get_ISO_8601_date),
    i(2, "Content"),
  })),

  -- Visual selection snippets
  s({trig = "box*", snippetType = "autosnippet"}, fmt([[
/*
 * {}
 */
]], {
    d(1, get_visual),
  })),

  -- Visual selection with bold markdown
  s({trig = "bold"}, fmt("**{}**", {
    d(1, get_visual),
  })),

  -- Visual selection with italic markdown
  s({trig = "ital"}, fmt("*{}*", {
    d(1, get_visual),
  })),

  -- Visual selection with code markdown
  s({trig = "code"}, fmt("`{}`", {
    d(1, get_visual),
  })),

  -- License header for code files
  s("license", fmt([[
/**
 * {}
 *
 * Copyright (c) {} {}
 *
 * {}
 */
]], {
    i(1, "Description"),
    f(function() return os.date("%Y") end, {}),
    i(2, "Author Name"),
    c(3, {
      t("MIT License"),
      t("Apache License 2.0"),
      t("GNU General Public License v3.0"),
      t("BSD 3-Clause License"),
      i(nil, "License"),
    }),
  })),
}


==================================================
File: snippets/tex/math.lua
==================================================

local helpers = require('personal.luasnip-helper-funcs')
local get_visual = helpers.get_visual

-- Math context detection 
local tex = {}
tex.in_mathzone = function() return vim.fn['vimtex#syntax#in_mathzone']() == 1 end
tex.in_text = function() return not tex.in_mathzone() end

-- Return snippet tables
return
{
  -- SUPERSCRIPT
  s({trig = "([%w%)%]%}])'", wordTrig=false, regTrig = true, snippetType="autosnippet"},
    fmta(
      "<>^{<>}",
      {
        f( function(_, snip) return snip.captures[1] end ),
        d(1, get_visual),
      }
    ),
    {condition = tex.in_mathzone}
  ),
  -- SUBSCRIPT
  s({trig = "([%w%)%]%}]);", wordTrig=false, regTrig = true, snippetType="autosnippet"},
    fmta(
      "<>_{<>}",
      {
        f( function(_, snip) return snip.captures[1] end ),
        d(1, get_visual),
      }
    ),
    {condition = tex.in_mathzone}
  ),
  -- SUBSCRIPT AND SUPERSCRIPT
  s({trig = "([%w%)%]%}])__", wordTrig=false, regTrig = true, snippetType="autosnippet"},
    fmta(
      "<>^{<>}_{<>}",
      {
        f( function(_, snip) return snip.captures[1] end ),
        i(1),
        i(2),
      }
    ),
    {condition = tex.in_mathzone}
  ),
  -- TEXT SUBSCRIPT
  s({trig = 'sd', snippetType="autosnippet", wordTrig=false},
    fmta("_{\\mathrm{<>}}",
      { d(1, get_visual) }
    ),
    {condition = tex.in_mathzone}
  ),
  -- SUPERSCRIPT SHORTCUT
  -- Places the first alphanumeric character after the trigger into a superscript.
  s({trig = '([%w%)%]%}])"([%w])', regTrig = true, wordTrig = false, snippetType="autosnippet"},
    fmta(
      "<>^{<>}",
      {
        f( function(_, snip) return snip.captures[1] end ),
        f( function(_, snip) return snip.captures[2] end ),
      }
    ),
    {condition = tex.in_mathzone}
  ),
  -- SUBSCRIPT SHORTCUT
  -- Places the first alphanumeric character after the trigger into a subscript.
  s({trig = '([%w%)%]%}]):([%w])', regTrig = true, wordTrig = false, snippetType="autosnippet"},
    fmta(
      "<>_{<>}",
      {
        f( function(_, snip) return snip.captures[1] end ),
        f( function(_, snip) return snip.captures[2] end ),
      }
    ),
    {condition = tex.in_mathzone}
  ),
  -- EULER'S NUMBER SUPERSCRIPT SHORTCUT
  s({trig = '([^%a])ee', regTrig = true, wordTrig = false, snippetType="autosnippet"},
    fmta(
      "<>e^{<>}",
      {
        f( function(_, snip) return snip.captures[1] end ),
        d(1, get_visual)
      }
    ),
    {condition = tex.in_mathzone}
  ),
  -- ZERO SUBSCRIPT SHORTCUT
  s({trig = '([%a%)%]%}])00', regTrig = true, wordTrig = false, snippetType="autosnippet"},
    fmta(
      "<>_{<>}",
      {
        f( function(_, snip) return snip.captures[1] end ),
        t("0")
      }
    ),
    {condition = tex.in_mathzone}
  ),
  -- MINUS ONE SUPERSCRIPT SHORTCUT
  s({trig = '([%a%)%]%}])11', regTrig = true, wordTrig = false, snippetType="autosnippet"},
    fmta(
      "<>_{<>}",
      {
        f( function(_, snip) return snip.captures[1] end ),
        t("-1")
      }
    ),
    {condition = tex.in_mathzone}
  ),
  -- J SUBSCRIPT SHORTCUT (since jk triggers snippet jump forward)
  s({trig = '([%a%)%]%}])JJ', wordTrig = false, regTrig = true, snippetType="autosnippet"},
    fmta(
      "<>_{<>}",
      {
        f( function(_, snip) return snip.captures[1] end ),
        t("j")
      }
    ),
    {condition = tex.in_mathzone}
  ),
  -- PLUS SUPERSCRIPT SHORTCUT
  s({trig = '([%a%)%]%}])%+%+', regTrig = true, wordTrig = false, snippetType="autosnippet"},
    fmta(
      "<>^{<>}",
      {
        f( function(_, snip) return snip.captures[1] end ),
        t("+")
      }
    ),
    {condition = tex.in_mathzone}
  ),
  -- COMPLEMENT SUPERSCRIPT
  s({trig = '([%a%)%]%}])CC', regTrig = true, wordTrig = false, snippetType="autosnippet"},
    fmta(
      "<>^{<>}",
      {
        f( function(_, snip) return snip.captures[1] end ),
        t("\\complement")
      }
    ),
    {condition = tex.in_mathzone}
  ),
  -- CONJUGATE (STAR) SUPERSCRIPT SHORTCUT
  s({trig = '([%a%)%]%}])%*%*', regTrig = true, wordTrig = false, snippetType="autosnippet"},
    fmta(
      "<>^{<>}",
      {
        f( function(_, snip) return snip.captures[1] end ),
        t("*")
      }
    ),
    {condition = tex.in_mathzone}
  ),
  -- VECTOR, i.e. \vec
  s({trig = "([^%a])vv", wordTrig = false, regTrig = true, snippetType="autosnippet"},
    fmta(
      "<>\\vec{<>}",
      {
        f( function(_, snip) return snip.captures[1] end ),
        d(1, get_visual),
      }
    ),
    {condition = tex.in_mathzone}
  ),
  -- DEFAULT UNIT VECTOR WITH SUBSCRIPT, i.e. \unitvector_{}
  s({trig = "([^%a])ue", wordTrig = false, regTrig = true, snippetType="autosnippet"},
    fmta(
      "<>\\unitvector_{<>}",
      {
        f( function(_, snip) return snip.captures[1] end ),
        d(1, get_visual),
      }
    ),
    {condition = tex.in_mathzone}
  ),
  -- UNIT VECTOR WITH HAT, i.e. \uvec{}
  s({trig = "([^%a])uv", wordTrig = false, regTrig = true, snippetType="autosnippet"},
    fmta(
      "<>\\uvec{<>}",
      {
        f( function(_, snip) return snip.captures[1] end ),
        d(1, get_visual),
      }
    ),
    {condition = tex.in_mathzone}
  ),
  -- MATRIX, i.e. \vec
  s({trig = "([^%a])mt", wordTrig = false, regTrig = true, snippetType="autosnippet"},
    fmta(
      "<>\\mat{<>}",
      {
        f( function(_, snip) return snip.captures[1] end ),
        d(1, get_visual),
      }
    ),
    {condition = tex.in_mathzone}
  ),
  -- FRACTION
  s({trig = "([^%a])ff", wordTrig = false, regTrig = true, snippetType="autosnippet"},
    fmta(
      "<>\\frac{<>}{<>}",
      {
        f( function(_, snip) return snip.captures[1] end ),
        d(1, get_visual),
        i(2),
      }
    ),
    {condition = tex.in_mathzone}
  ),
  -- ANGLE
  s({trig = "([^%a])gg", regTrig = true, wordTrig = false, snippetType="autosnippet"},
    fmta(
      "<>\\ang{<>}",
      {
        f( function(_, snip) return snip.captures[1] end ),
        d(1, get_visual),
      }
    ),
    {condition = tex.in_mathzone}
  ),
  -- ABSOLUTE VALUE
  s({trig = "([^%a])aa", regTrig = true, wordTrig = false, snippetType="autosnippet"},
    fmta(
      "<>\\abs{<>}",
      {
        f( function(_, snip) return snip.captures[1] end ),
        d(1, get_visual),
      }
    ),
    {condition = tex.in_mathzone}
  ),
  -- SQUARE ROOT
  s({trig = "([^%\\])sq", wordTrig = false, regTrig = true, snippetType="autosnippet"},
    fmta(
      "<>\\sqrt{<>}",
      {
        f( function(_, snip) return snip.captures[1] end ),
        d(1, get_visual),
      }
    ),
    {condition = tex.in_mathzone}
  ),
  -- BINOMIAL SYMBOL
  s({trig = "([^%\\])bnn", wordTrig = false, regTrig = true, snippetType="autosnippet"},
    fmta(
      "<>\\binom{<>}{<>}",
      {
        f( function(_, snip) return snip.captures[1] end ),
        i(1),
        i(2),
      }
    ),
    {condition = tex.in_mathzone}
  ),
  -- LOGARITHM WITH BASE SUBSCRIPT
  s({trig = "([^%a%\\])ll", wordTrig = false, regTrig = true, snippetType="autosnippet"},
    fmta(
      "<>\\log_{<>}",
      {
        f( function(_, snip) return snip.captures[1] end ),
        i(1),
      }
    ),
    {condition = tex.in_mathzone}
  ),
  -- DERIVATIVE with denominator only
  s({trig = "([^%a])dV", wordTrig = false, regTrig = true, snippetType="autosnippet"},
    fmta(
      "<>\\dvOne{<>}",
      {
        f( function(_, snip) return snip.captures[1] end ),
        d(1, get_visual),
      }
    ),
    {condition = tex.in_mathzone}
  ),
  -- DERIVATIVE with numerator and denominator
  s({trig = "([^%a])dvv", wordTrig = false, regTrig = true, snippetType="autosnippet"},
    fmta(
      "<>\\dv{<>}{<>}",
      {
        f( function(_, snip) return snip.captures[1] end ),
        i(1),
        i(2)
      }
    ),
    {condition = tex.in_mathzone}
  ),
  -- DERIVATIVE with numerator, denominator, and higher-order argument
  s({trig = "([^%a])ddv", wordTrig = false, regTrig = true, snippetType="autosnippet"},
    fmta(
      "<>\\dvN{<>}{<>}{<>}",
      {
        f( function(_, snip) return snip.captures[1] end ),
        i(1),
        i(2),
        i(3),
      }
    ),
    {condition = tex.in_mathzone}
  ),
  -- PARTIAL DERIVATIVE with denominator only
  s({trig = "([^%a])pV", wordTrig = false, regTrig = true, snippetType="autosnippet"},
    fmta(
      "<>\\pdvOne{<>}",
      {
        f( function(_, snip) return snip.captures[1] end ),
        d(1, get_visual),
      }
    ),
    {condition = tex.in_mathzone}
  ),
  -- PARTIAL DERIVATIVE with numerator and denominator
  s({trig = "([^%a])pvv", wordTrig = false, regTrig = true, snippetType="autosnippet"},
    fmta(
      "<>\\pdv{<>}{<>}",
      {
        f( function(_, snip) return snip.captures[1] end ),
        i(1),
        i(2)
      }
    ),
    {condition = tex.in_mathzone}
  ),
  -- PARTIAL DERIVATIVE with numerator, denominator, and higher-order argument
  s({trig = "([^%a])ppv", wordTrig = false, regTrig = true, snippetType="autosnippet"},
    fmta(
      "<>\\pdvN{<>}{<>}{<>}",
      {
        f( function(_, snip) return snip.captures[1] end ),
        i(1),
        i(2),
        i(3),
      }
    ),
    {condition = tex.in_mathzone}
  ),
  -- SUM with lower limit
  s({trig = "([^%a])sM", wordTrig = false, regTrig = true, snippetType="autosnippet"},
    fmta(
      "<>\\sum_{<>}",
      {
        f( function(_, snip) return snip.captures[1] end ),
        i(1),
      }
    ),
    {condition = tex.in_mathzone}
  ),
  -- SUM with upper and lower limit
  s({trig = "([^%a])smm", wordTrig = false, regTrig = true, snippetType="autosnippet"},
    fmta(
      "<>\\sum_{<>}^{<>}",
      {
        f( function(_, snip) return snip.captures[1] end ),
        i(1),
        i(2),
      }
    ),
    {condition = tex.in_mathzone}
  ),
  -- INTEGRAL with upper and lower limit
  s({trig = "([^%a])intt", wordTrig = false, regTrig = true, snippetType="autosnippet"},
    fmta(
      "<>\\int_{<>}^{<>}",
      {
        f( function(_, snip) return snip.captures[1] end ),
        i(1),
        i(2),
      }
    ),
    {condition = tex.in_mathzone}
  ),
  -- INTEGRAL from positive to negative infinity
  s({trig = "([^%a])intf", wordTrig = false, regTrig = true, snippetType="autosnippet"},
    fmta(
      "<>\\int_{\\infty}^{\\infty}",
      {
        f( function(_, snip) return snip.captures[1] end ),
      }
    ),
    {condition = tex.in_mathzone}
  ),
  -- BOXED command
  s({trig = "([^%a])bb", wordTrig = false, regTrig = true, snippetType="autosnippet"},
    fmta(
      "<>\\boxed{<>}",
      {
        f( function(_, snip) return snip.captures[1] end ),
        d(1, get_visual)
      }
    ),
    {condition = tex.in_mathzone}
  ),
  --
  -- BEGIN STATIC SNIPPETS
  --

  -- DIFFERENTIAL, i.e. \diff
  s({trig = "df", snippetType="autosnippet", priority=2000, snippetType="autosnippet"},
    {
      t("\\diff"),
    },
    {condition = tex.in_mathzone}
  ),
  -- BASIC INTEGRAL SYMBOL, i.e. \int
  s({trig = "in1", snippetType="autosnippet"},
    {
      t("\\int"),
    },
    {condition = tex.in_mathzone}
  ),
  -- DOUBLE INTEGRAL, i.e. \iint
  s({trig = "in2", snippetType="autosnippet"},
    {
      t("\\iint"),
    },
    {condition = tex.in_mathzone}
  ),
  -- TRIPLE INTEGRAL, i.e. \iiint
  s({trig = "in3", snippetType="autosnippet"},
    {
      t("\\iiint"),
    },
    {condition = tex.in_mathzone}
  ),
  -- CLOSED SINGLE INTEGRAL, i.e. \oint
  s({trig = "oi1", snippetType="autosnippet"},
    {
      t("\\oint"),
    },
    {condition = tex.in_mathzone}
  ),
  -- CLOSED DOUBLE INTEGRAL, i.e. \oiint
  s({trig = "oi2", snippetType="autosnippet"},
    {
      t("\\oiint"),
    },
    {condition = tex.in_mathzone}
  ),
  -- GRADIENT OPERATOR, i.e. \grad
  s({trig = "gdd", snippetType="autosnippet"},
    {
      t("\\grad "),
    },
    {condition = tex.in_mathzone}
  ),
  -- CURL OPERATOR, i.e. \curl
  s({trig = "cll", snippetType="autosnippet"},
    {
      t("\\curl "),
    },
    {condition = tex.in_mathzone}
  ),
  -- DIVERGENCE OPERATOR, i.e. \divergence
  s({trig = "DI", snippetType="autosnippet"},
    {
      t("\\div "),
    },
    {condition = tex.in_mathzone}
  ),
  -- LAPLACIAN OPERATOR, i.e. \laplacian
  s({trig = "laa", snippetType="autosnippet"},
    {
      t("\\laplacian "),
    },
    {condition = tex.in_mathzone}
  ),
  -- PARALLEL SYMBOL, i.e. \parallel
  s({trig = "||", snippetType="autosnippet"},
    {
      t("\\parallel"),
    }
  ),
  -- CDOTS, i.e. \cdots
  s({trig = "cdd", snippetType="autosnippet"},
    {
      t("\\cdots"),
    }
  ),
  -- LDOTS, i.e. \ldots
  s({trig = "ldd", snippetType="autosnippet"},
    {
      t("\\ldots"),
    }
  ),
  -- EQUIV, i.e. \equiv
  s({trig = "eqq", snippetType="autosnippet"},
    {
      t("\\equiv "),
    }
  ),
  -- SETMINUS, i.e. \setminus
  s({trig = "stm", snippetType="autosnippet"},
    {
      t("\\setminus "),
    }
  ),
  -- SUBSET, i.e. \subset
  s({trig = "sbb", snippetType="autosnippet"},
    {
      t("\\subset "),
    }
  ),
  -- APPROX, i.e. \approx
  s({trig = "px", snippetType="autosnippet"},
    {
      t("\\approx "),
    },
    {condition = tex.in_mathzone}
  ),
  -- PROPTO, i.e. \propto
  s({trig = "pt", snippetType="autosnippet"},
    {
      t("\\propto "),
    },
    {condition = tex.in_mathzone}
  ),
  -- COLON, i.e. \colon
  s({trig = "::", snippetType="autosnippet"},
    {
      t("\\colon "),
    }
  ),
  -- IMPLIES, i.e. \implies
  s({trig = ">>", snippetType="autosnippet"},
    {
      t("\\implies "),
    }
  ),
  -- DOT PRODUCT, i.e. \cdot
  s({trig = ",.", snippetType="autosnippet"},
    {
      t("\\cdot "),
    }
  ),
  -- CROSS PRODUCT, i.e. \times
  s({trig = "xx", snippetType="autosnippet"},
    {
      t("\\times "),
    }
  ),
}


==================================================
File: snippets/tex/system.lua
==================================================

local helpers = require('personal.luasnip-helper-funcs')
local get_visual = helpers.get_visual

local line_begin = require("luasnip.extras.expand_conditions").line_begin

-- Math context detection 
local tex = {}
tex.in_mathzone = function() return vim.fn['vimtex#syntax#in_mathzone']() == 1 end
tex.in_text = function() return not tex.in_mathzone() end

-- Return snippet tables
return
  {
    -- ANNOTATE (custom command for annotating equation derivations)
    s({trig = "ann", snippetType="autosnippet"},
      fmta(
        [[
      \annotate{<>}{<>}
      ]],
        {
          i(1),
          d(2, get_visual),
        }
      )
    ),
    -- REFERENCE
    s({trig = " RR", snippetType="autosnippet", wordTrig=false},
      fmta(
        [[
      ~\ref{<>}
      ]],
        {
          d(1, get_visual),
        }
      )
    ),
    -- DOCUMENTCLASS
    s({trig = "dcc", snippetType="autosnippet"},
      fmta(
        [=[
        \documentclass[<>]{<>}
        ]=],
        {
          i(1, "a4paper"),
          i(2, "article"),
        }
      ),
      { condition = line_begin }
    ),
    -- USE A LATEX PACKAGE
    s({trig = "pack", snippetType="autosnippet"},
      fmta(
        [[
        \usepackage{<>}
        ]],
        {
          d(1, get_visual),
        }
      ),
      { condition = line_begin }
    ),
    -- INPUT a LaTeX file
    s({trig = "inn", snippetType="autosnippet"},
      fmta(
        [[
      \input{<><>}
      ]],
        {
          i(1, "~/dotfiles/config/latex/templates/"),
          i(2)
        }
      ),
      { condition = line_begin }
    ),
    -- LABEL
    s({trig = "lbl", snippetType="autosnippet"},
      fmta(
        [[
      \label{<>}
      ]],
        {
          d(1, get_visual),
        }
      )
    ),
    -- HPHANTOM
    s({trig = "hpp", snippetType="autosnippet"},
      fmta(
        [[
      \hphantom{<>}
      ]],
        {
          d(1, get_visual),
        }
      )
    ),
    s({trig = "TODOO", snippetType="autosnippet"},
      fmta(
        [[\TODO{<>}]],
        {
          d(1, get_visual),
        }
      )
    ),
    s({trig="nc"},
      fmta(
        [[\newcommand{<>}{<>}]],
        {
          i(1),
          i(2)
        }
      ),
      {condition = line_begin}
    ),
    s({trig="sii", snippetType="autosnippet"},
      fmta(
        [[\si{<>}]],
        {
          i(1),
        }
      )
    ),
    s({trig="SI"},
      fmta(
        [[\SI{<>}{<>}]],
        {
          i(1),
          i(2)
        }
      )
    ),
    -- URL 
    s({trig="url"},
      fmta(
        [[\url{<>}]],
        {
          d(1, get_visual),
        }
      )
    ),
    -- href command with URL in visual selection
    s({trig="LU", snippetType="autosnippet"},
      fmta(
        [[\href{<>}{<>}]],
        {
          d(1, get_visual),
          i(2)
        }
      )
    ),
    -- href command with text in visual selection
    s({trig="LL", snippetType="autosnippet"},
      fmta(
        [[\href{<>}{<>}]],
        {
          i(1),
          d(2, get_visual)
        }
      )
    ),
    -- HSPACE
    s({trig="hss", snippetType="autosnippet"},
      fmta(
        [[\hspace{<>}]],
        {
          d(1, get_visual),
        }
      )
    ),
    -- VSPACE
    s({trig="vss", snippetType="autosnippet"},
      fmta(
        [[\vspace{<>}]],
        {
          d(1, get_visual),
        }
      )
    ),
    -- SECTION
    s({trig="h1", snippetType="autosnippet"},
      fmta(
        [[\section{<>}]],
        {
          d(1, get_visual),
        }
      )
    ),
    -- SUBSECTION
    s({trig="h2", snippetType="autosnippet"},
      fmta(
        [[\subsection{<>}]],
        {
          d(1, get_visual),
        }
      )
    ),
    -- SUBSUBSECTION
    s({trig="h3", snippetType="autosnippet"},
      fmta(
        [[\subsubsection{<>}]],
        {
          d(1, get_visual),
        }
      )
    ),
  }


==================================================
File: snippets/tex/tmp.lua
==================================================

local helpers = require('personal.luasnip-helper-funcs')
local get_visual = helpers.get_visual

local line_begin = require("luasnip.extras.expand_conditions").line_begin

-- Math context detection 
local tex = {}
tex.in_mathzone = function() return vim.fn['vimtex#syntax#in_mathzone']() == 1 end
tex.in_text = function() return not tex.in_mathzone() end


return {

  -- Equation, choice for labels
  s({trig="beq", dscr="Expands 'beq' into an equation environment, with a choice for labels", snippetType="autosnippet"},
    fmta(
      [[
        \begin{equation}<>
          <>
        \end{equation}
      ]],
      { c(1, 
            {
              sn(2,   -- Choose to specify an equation label
                {
                  t("\\label{eq:"),
                  i(1),
                  t("}"),
                }
              ),
              t([[]]), -- Choose no label
            },
            {}
          ),
        i(2) }
    )
  ),

  -- Figure environment
  s({trig="foofig", dscr="Use 'fig' for figure environmennt, with options"},
    fmta(
      [[
        \begin{figure}<>
          \centering
          \includegraphics<>{<>}
          \caption{<>}
          \label{fig:<>}
        \end{figure}
      ]],
      { 
        -- Optional [htbp] field
        c(1, 
            {
              t([[]]),      -- Choice 1, empty
              t("[htbp]"),  -- Choice 2, this may be turned into a snippet
            },
            {}
          ),
        -- Options for includegraphics
        c(2, 
            {
              t([[]]), -- Choice 1, empty
              sn(3,    -- Choice 2, this may be turned into a snippet
                {
                  t("[width="),
                  i(1),
                  t("\\textwidth]"),
                }
              ),
            },
            {}
        ),
        i(3, "filename"),
        i(4, "text"), 
        i(5, "label"), 
      }
    ),
    {condition = line_begin}
  ),

}


==================================================
File: snippets/tex/static.lua
==================================================

local helpers = require('personal.luasnip-helper-funcs')
local get_visual = helpers.get_visual

local line_begin = require("luasnip.extras.expand_conditions").line_begin

-- Environment/syntax context detection 
local tex = {}
tex.in_mathzone = function() return vim.fn['vimtex#syntax#in_mathzone']() == 1 end
tex.in_text = function() return not tex.in_mathzone() end
tex.in_tikz = function()
  local is_inside = vim.fn['vimtex#env#is_inside']("tikzpicture")
  return (is_inside[1] > 0 and is_inside[2] > 0)
end

-- Return snippet tables
return
  {
    s({trig="q"},
      {
        t("\\quad "),
      }
    ),
    s({trig="qq", snippetType="autosnippet"},
      {
        t("\\qquad "),
      }
    ),
    s({trig="npp", snippetType="autosnippet"},
      {
        t({"\\newpage", ""}),
      },
      {condition = line_begin}
    ),
    s({trig="which", snippetType="autosnippet"},
      {
        t("\\text{ for which } "),
      },
      {condition = tex.in_mathzone}
    ),
    s({trig="all", snippetType="autosnippet"},
      {
        t("\\text{ for all } "),
      },
      {condition = tex.in_mathzone}
    ),
    s({trig="and", snippetType="autosnippet"},
      {
        t("\\quad \\text{and} \\quad"),
      },
      {condition = tex.in_mathzone}
    ),
    s({trig="forall", snippetType="autosnippet"},
      {
        t("\\text{ for all } "),
      },
      {condition = tex.in_mathzone}
    ),
    s({trig = "toc", snippetType="autosnippet"},
      {
        t("\\tableofcontents"),
      },
      { condition = line_begin }
    ),
    s({trig="inff", snippetType="autosnippet"},
      {
        t("\\infty"),
      }
    ),
    s({trig="ii", snippetType="autosnippet"},
      {
        t("\\item "),
      },
      { condition = line_begin }
    ),
    s({trig = "--", snippetType="autosnippet"},
      {t('% --------------------------------------------- %')},
      {condition = line_begin}
    ),
    -- HLINE WITH EXTRA VERTICAL SPACE
    s({trig = "hl"},
      {t('\\hline {\\rule{0pt}{2.5ex}} \\hspace{-7pt}')},
      {condition = line_begin}
    ),
  }


==================================================
File: snippets/tex/delimiter.lua
==================================================

local helpers = require('personal.luasnip-helper-funcs')
local get_visual = helpers.get_visual

-- Math context detection 
local tex = {}
tex.in_mathzone = function() return vim.fn['vimtex#syntax#in_mathzone']() == 1 end
tex.in_text = function() return not tex.in_mathzone() end

-- Return snippet tables
return
{
  -- LEFT/RIGHT PARENTHESES
  s({trig = "([^%a])l%(", regTrig = true, wordTrig = false, snippetType="autosnippet"},
    fmta(
      "<>\\left(<>\\right)",
      {
        f( function(_, snip) return snip.captures[1] end ),
        d(1, get_visual),
      }
    )
  ),
  -- LEFT/RIGHT SQUARE BRACES
  s({trig = "([^%a])l%[", regTrig = true, wordTrig = false, snippetType="autosnippet"},
    fmta(
      "<>\\left[<>\\right]",
      {
        f( function(_, snip) return snip.captures[1] end ),
        d(1, get_visual),
      }
    )
  ),
  -- LEFT/RIGHT CURLY BRACES
  s({trig = "([^%a])l%{", regTrig = true, wordTrig = false, snippetType="autosnippet"},
    fmta(
      "<>\\left\\{<>\\right\\}",
      {
        f( function(_, snip) return snip.captures[1] end ),
        d(1, get_visual),
      }
    )
  ),
  -- BIG PARENTHESES
  s({trig = "([^%a])b%(", regTrig = true, wordTrig = false, snippetType="autosnippet"},
    fmta(
      "<>\\big(<>\\big)",
      {
        f( function(_, snip) return snip.captures[1] end ),
        d(1, get_visual),
      }
    )
  ),
  -- BIG SQUARE BRACES
  s({trig = "([^%a])b%[", regTrig = true, wordTrig = false, snippetType="autosnippet"},
    fmta(
      "<>\\big[<>\\big]",
      {
        f( function(_, snip) return snip.captures[1] end ),
        d(1, get_visual),
      }
    )
  ),
  -- BIG CURLY BRACES
  s({trig = "([^%a])b%{", regTrig = true, wordTrig = false, snippetType="autosnippet"},
    fmta(
      "<>\\big\\{<>\\big\\}",
      {
        f( function(_, snip) return snip.captures[1] end ),
        d(1, get_visual),
      }
    )
  ),
  -- ESCAPED CURLY BRACES
  s({trig = "([^%a])\\%{", regTrig = true, wordTrig = false, snippetType="autosnippet", priority=2000},
    fmta(
      "<>\\{<>\\}",
      {
        f( function(_, snip) return snip.captures[1] end ),
        d(1, get_visual),
      }
    )
  ),
  -- LATEX QUOTATION MARK
  s({trig = "``", snippetType="autosnippet"},
    fmta(
      "``<>''",
      {
        d(1, get_visual),
      }
    )
  ),
  s({trig = "tiit", snippetType="autosnippet"},
    fmta(
      "\\toggletext{<>}",
      {
        d(1, get_visual),
      }
    )
  ),
}



==================================================
File: snippets/tex/fonts.lua
==================================================

local helpers = require('personal.luasnip-helper-funcs')
-- local get_visual = helpers.get_visual
local get_visual = function(args, parent)
  if (#parent.snippet.env.LS_SELECT_RAW > 0) then
    return sn(nil, i(1, parent.snippet.env.LS_SELECT_RAW))
  else  -- If LS_SELECT_RAW is empty, return a blank insert node
    return sn(nil, i(1))
  end
end
-- A logical OR of `line_begin` and the regTrig '[^%a]trig'
function line_begin_or_non_letter(line_to_cursor, matched_trigger)
  local line_begin = line_to_cursor:sub(1, -(#matched_trigger + 1)):match("^%s*$")
  local non_letter = line_to_cursor:sub(-(#matched_trigger + 1), -(#matched_trigger + 1)):match("[^%a]")
  return line_begin or non_letter
end

-- Math context detection 
local tex = {}
tex.in_mathzone = function() return vim.fn['vimtex#syntax#in_mathzone']() == 1 end
tex.in_text = function() return not tex.in_mathzone() end

local line_begin = function(line_to_cursor, matched_trigger)
  -- +1 because `string.sub("abcd", 1, -2)` -> abc
  return line_to_cursor:sub(1, -(#matched_trigger + 1)):match("^%s*$")
end

-- Return snippet tables
return
  {
    -- TYPEWRITER i.e. \texttt
    s({trig = "([^%a])tt", regTrig = true, wordTrig = false, snippetType="autosnippet", priority=2000},
      fmta(
        "<>\\texttt{<>}",
        {
          f( function(_, snip) return snip.captures[1] end ),
          d(1, get_visual),
        }
      ),
      {condition = tex.in_text}
    ),
    -- ITALIC i.e. \textit
    s({trig = "([^%a])tii", regTrig = true, wordTrig = false, snippetType="autosnippet"},
      fmta(
        "<>\\textit{<>}",
        {
          f( function(_, snip) return snip.captures[1] end ),
          d(1, get_visual),
        }
      )
    ),
    -- BOLD i.e. \textbf
    s({trig = "tbb", snippetType="autosnippet"},
      fmta(
        "\\textbf{<>}",
        {
          d(1, get_visual),
        }
      )
    ),
    -- MATH ROMAN i.e. \mathrm
    s({trig = "([^%a])rmm", regTrig = true, wordTrig = false, snippetType="autosnippet"},
      fmta(
        "<>\\mathrm{<>}",
        {
          f( function(_, snip) return snip.captures[1] end ),
          d(1, get_visual),
        }
      )
    ),
    -- MATH CALIGRAPHY i.e. \mathcal
    s({trig = "([^%a])mcc", regTrig = true, wordTrig = false, snippetType="autosnippet"},
      fmta(
        "<>\\mathcal{<>}",
        {
          f( function(_, snip) return snip.captures[1] end ),
          d(1, get_visual),
        }
      )
    ),
    -- MATH BOLDFACE i.e. \mathbf
    s({trig = "([^%a])mbf", regTrig = true, wordTrig = false, snippetType="autosnippet"},
      fmta(
        "<>\\mathbf{<>}",
        {
          f( function(_, snip) return snip.captures[1] end ),
          d(1, get_visual),
        }
      )
    ),
    -- MATH BLACKBOARD i.e. \mathbb
    s({trig = "([^%a])mbb", regTrig = true, wordTrig = false, snippetType="autosnippet"},
      fmta(
        "<>\\mathbb{<>}",
        {
          f( function(_, snip) return snip.captures[1] end ),
          d(1, get_visual),
        }
      )
    ),
    -- REGULAR TEXT i.e. \text (in math environments)
    s({trig = "([^%a])tee", regTrig = true, wordTrig = false, snippetType="autosnippet"},
      fmta(
        "<>\\text{<>}",
        {
          f( function(_, snip) return snip.captures[1] end ),
          d(1, get_visual),
        }
      ),
      { condition = tex.in_mathzone }
    ),
    -- For red color
    s({trig = "([^%a])rrr", regTrig = true, wordTrig = false, snippetType="autosnippet"},
      fmta(
        [[{\color{<>}<>}]],
        {
          t("red"),
          d(1, get_visual),
        }
      )
    ),
  }


==================================================
File: snippets/tex/luatex.lua
==================================================

local helpers = require('personal.luasnip-helper-funcs')
local get_visual = helpers.get_visual
local line_begin = require("luasnip.extras.expand_conditions").line_begin

-- Return snippet tables
return
  {
    -- tex.sprint
    s({trig = "tpp", snippetType="autosnippet"},
      fmta(
      [[
        tex.sprint(<>)
      ]],
        {
          d(1, get_visual),
        }
      )
    ),
  }


==================================================
File: snippets/tex/test.lua
==================================================

local ls = require("luasnip")
local s = ls.snippet
local t = ls.text_node
local i = ls.insert_node

return {
    s("test", { t("This is a test snippet.") }),
}



==================================================
File: snippets/tex/environments.lua
==================================================

local ls = require("luasnip")
   local s = ls.snippet
   local sn = ls.snippet_node
   local t = ls.text_node
   local i = ls.insert_node
   local f = ls.function_node
   local d = ls.dynamic_node
   local rep = require("luasnip.extras").rep
   local fmta = require("luasnip.extras.fmt").fmta
   local helpers = require('personal.luasnip-helper-funcs')
   local get_visual = helpers.get_visual

   -- Math context detection
   local tex = {}
   tex.in_mathzone = function() return vim.fn['vimtex#syntax#in_mathzone']() == 1 end
   tex.in_text = function() return not tex.in_mathzone() end
   local line_begin = require("luasnip.extras.expand_conditions").line_begin
--local helpers = require('personal.luasnip-helper-funcs')
--local get_visual = helpers.get_visual

-- Math context detection
--local tex = {}
--tex.in_mathzone = function() return vim.fn['vimtex#syntax#in_mathzone']() == 1 end
--tex.in_text = function() return not tex.in_mathzone() end
--
--local line_begin = require("luasnip.extras.expand_conditions").line_begin

-- Return snippet tables
return
  {
    -- GENERIC ENVIRONMENT
    s({trig="new", snippetType="autosnippet"},
      fmta(
        [[
        \begin{<>}
            <>
        \end{<>}
      ]],
        {
          i(1),
          d(2, get_visual),
          rep(1),
        }
      ),
      {condition = line_begin}
    ),
    -- ENVIRONMENT WITH ONE EXTRA ARGUMENT
    s({trig="n2", snippetType="autosnippet"},
      fmta(
        [[
        \begin{<>}{<>}
            <>
        \end{<>}
      ]],
        {
          i(1),
          i(2),
          d(3, get_visual),
          rep(1),
        }
      ),
      { condition = line_begin }
    ),
    -- ENVIRONMENT WITH TWO EXTRA ARGUMENTS
    s({trig="n3", snippetType="autosnippet"},
      fmta(
        [[
        \begin{<>}{<>}{<>}
            <>
        \end{<>}
      ]],
        {
          i(1),
          i(2),
          i(3),
          d(4, get_visual),
          rep(1),
        }
      ),
      { condition = line_begin }
    ),
    -- TOPIC ENVIRONMENT (my custom tcbtheorem environment)
    s({trig="nt", snippetType="autosnippet"},
      fmta(
        [[
        \begin{topic}{<>}{<>}
            <>
        \end{topic}
      ]],
        {
          i(1),
          i(2),
          d(3, get_visual),
        }
      ),
      { condition = line_begin }
    ),
    -- EQUATION
    s({trig="nn", snippetType="autosnippet"},
      fmta(
        [[
        \begin{equation*}
            <>
        \end{equation*}
      ]],
        {
          i(1),
        }
      ),
      { condition = line_begin }
    ),
    -- SPLIT EQUATION
    s({trig="ss", snippetType="autosnippet"},
      fmta(
        [[
        \begin{equation*}
            \begin{split}
                <>
            \end{split}
        \end{equation*}
      ]],
        {
          d(1, get_visual),
        }
      ),
      { condition = line_begin }
    ),
    -- ALIGN
    s({trig="all", snippetType="autosnippet"},
      fmta(
        [[
        \begin{align*}
            <>
        \end{align*}
      ]],
        {
          i(1),
        }
      ),
      {condition = line_begin}
    ),
    -- ITEMIZE
    s({trig="itt", snippetType="autosnippet"},
      fmta(
        [[
        \begin{itemize}

            \item <>

        \end{itemize}
      ]],
        {
          i(0),
        }
      ),
      {condition = line_begin}
    ),
    -- ENUMERATE
    s({trig="enn", snippetType="autosnippet"},
      fmta(
        [[
        \begin{enumerate}

            \item <>

        \end{enumerate}
      ]],
        {
          i(0),
        }
      )
    ),
    -- INLINE MATH
    s({trig = "([^%l])mm", regTrig = true, wordTrig = false, snippetType="autosnippet"},
      fmta(
        "<>$<>$",
        {
          f( function(_, snip) return snip.captures[1] end ),
          d(1, get_visual),
        }
      )
    ),
    -- INLINE MATH ON NEW LINE
    s({trig = "^mm", regTrig = true, wordTrig = false, snippetType="autosnippet"},
      fmta(
        "$<>$",
{
          i(1),
        })),
    -- FIGURE
    s({trig = "fig"},
      fmta(
        [[
        \begin{figure}[htb!]
          \centering
          \includegraphics[width=<>\linewidth]{<>}
          \caption{<>}
          \label{fig:<>}
        \end{figure}
        ]],
        {
          i(1),
          i(2),
          i(3),
          i(4),
        }
      ),
      { condition = line_begin }
    ),
    s({trig = "lua", snippetType = "autosnippet"},
      fmta(
        [[
        %! TeX program = lualatex
        ]],
        {}
      ),
      {
        condition = function()
          return vim.fn.line(".") == 1
        end
      }
    ),

  }


==================================================
File: snippets/tex/greek.lua
==================================================

-- Return snippet tables
return
{
  s({trig=";a", snippetType="autosnippet"},
    {
      t("\\alpha"),
  }),
  s({trig=";b", snippetType="autosnippet"},
    {
      t("\\beta"),
  }),
  s({trig=";g", snippetType="autosnippet"},
    {
      t("\\gamma"),
  }),
  s({trig=";G", snippetType="autosnippet"},
    {
      t("\\Gamma"),
  }),
  s({trig=";d", snippetType="autosnippet"},
    {
      t("\\delta"),
  }),
  s({trig=";D", snippetType="autosnippet"},
    {
      t("\\Delta"),
  }),
  s({trig=";e", snippetType="autosnippet"},
    {
      t("\\epsilon"),
  }),
  s({trig=";ve", snippetType="autosnippet"},
    {
      t("\\varepsilon"),
  }),
  s({trig=";z", snippetType="autosnippet"},
    {
      t("\\zeta"),
  }),
  s({trig=";h", snippetType="autosnippet"},
    {
      t("\\eta"),
  }),
  s({trig=";o", snippetType="autosnippet"},
    {
      t("\\theta"),
  }),
  s({trig=";vo", snippetType="autosnippet"},
    {
      t("\\vartheta"),
  }),
  s({trig=";O", snippetType="autosnippet"},
    {
      t("\\Theta"),
  }),
  s({trig=";k", snippetType="autosnippet"},
    {
      t("\\kappa"),
  }),
  s({trig=";l", snippetType="autosnippet"},
    {
      t("\\lambda"),
  }),
  s({trig=";L", snippetType="autosnippet"},
    {
      t("\\Lambda"),
  }),
  s({trig=";m", snippetType="autosnippet"},
    {
      t("\\mu"),
  }),
  s({trig=";n", snippetType="autosnippet"},
    {
      t("\\nu"),
  }),
  s({trig=";x", snippetType="autosnippet"},
    {
      t("\\xi"),
  }),
  s({trig=";X", snippetType="autosnippet"},
    {
      t("\\Xi"),
  }),
  s({trig=";i", snippetType="autosnippet"},
    {
      t("\\pi"),
  }),
  s({trig=";I", snippetType="autosnippet"},
    {
      t("\\Pi"),
  }),
  s({trig=";r", snippetType="autosnippet"},
    {
      t("\\rho"),
  }),
  s({trig=";s", snippetType="autosnippet"},
    {
      t("\\sigma"),
  }),
  s({trig=";S", snippetType="autosnippet"},
    {
      t("\\Sigma"),
  }),
  s({trig=";t", snippetType="autosnippet"},
    {
      t("\\tau"),
  }),
  s({trig=";f", snippetType="autosnippet"},
    {
      t("\\phi"),
  }),
  s({trig=";vf", snippetType="autosnippet"},
    {
      t("\\varphi"),
  }),
  s({trig=";F", snippetType="autosnippet"},
    {
      t("\\Phi"),
  }),
  s({trig=";c", snippetType="autosnippet"},
    {
      t("\\chi"),
  }),
  s({trig=";p", snippetType="autosnippet"},
    {
      t("\\psi"),
  }),
  s({trig=";P", snippetType="autosnippet"},
    {
      t("\\Psi"),
  }),
  s({trig=";w", snippetType="autosnippet"},
    {
      t("\\omega"),
  }),
  s({trig=";W", snippetType="autosnippet"},
    {
      t("\\Omega"),
  }),
}


==================================================
File: snippets/sv/non_synthesizable.lua
==================================================

local ls = require("luasnip")
local s = ls.snippet
local sn = ls.snippet_node
local t = ls.text_node
local i = ls.insert_node
local f = ls.function_node
local d = ls.dynamic_node
local c = ls.choice_node
local fmt = require("luasnip.extras.fmt").fmt
local fmta = require("luasnip.extras.fmt").fmta
local rep = require("luasnip.extras").rep
local helpers = require('personal.luasnip-helper-funcs')
local get_visual = helpers.get_visual

return {
  -- Initial block
  s({trig="init", descr="Initial block"},
    fmt(
      [[
      initial begin
        {}
      end
      ]],
      {d(1, function(_, snip)
        return sn(1, {i(1, snip.env.TM_SELECTED_TEXT[1] or "")})
      end)}
    )
  ),
  
  -- Task declaration
  s({trig="task", descr="Task declaration"},
    fmt(
      [[
      task {};
        {}
      endtask
      ]],
      {i(1, "task_name"), i(0)}
    )
  ),
  
  -- Function declaration
  s({trig="func", descr="Function declaration"},
    fmt(
      [[
      function {} {};
        {}
        return {};
      endfunction
      ]],
      {i(1, "return_type"), i(2, "func_name"), i(3), i(0)}
    )
  ),
  
  -- Assertion
  s({trig="assert", descr="Assertion"},
    fmt(
      [[
      assert ({}) else $error("{}: {}", {});
      ]],
      {i(1, "condition"), i(2, "Error message"), i(3, "variable"), i(0)}
    )
  ),
  
  -- Testbench template
  s({trig="tb", descr="Testbench template"},
    fmt(
      [[
      `timescale 1ns/1ps
      module {}_tb;
        // Testbench signals
        logic clk, rst_n;
        
        // DUT instantiation
        {} dut (
          .clk(clk),
          .rst_n(rst_n)
          // Add other ports here
        );
        
        // Clock generation
        always #5 clk = ~clk;
        
        initial begin
          // Initialize signals
          clk = 0;
          rst_n = 0;
          
          // Reset
          #10 rst_n = 1;
          
          // Test sequence
          {}
          
          $finish;
        end
      endmodule
      ]],
      {i(1, "module_name"), rep(1), i(0)}
    )
  ),

  -- Fork-join
  s({trig="fork", descr="Fork-join block"},
    fmt(
      [[
      fork
        begin
          {}
        end
        begin
          {}
        end
      join{}
      ]],
      {i(1), i(2), c(3, {t(""), t("_any"), t("_none")})}
    )
  ),

  -- Semaphore declaration and usage
  s({trig="sema", descr="Semaphore declaration and usage"},
    fmt(
      [[
      semaphore {};
      {} = new({}); // Initialize semaphore

      // Usage:
      {}.get({}); // Acquire semaphore
      // Critical section
      {}.put({}); // Release semaphore
      ]],
      {i(1, "sema_name"), rep(1), i(2, "initial_keys"), rep(1), i(3, "keys"), rep(1), rep(3)}
    )
  ),

  -- Mailbox declaration and usage
  s({trig="mbox", descr="Mailbox declaration and usage"},
    fmt(
      [[
      mailbox {};
      {} = new(); // Create mailbox

      // Usage:
      {}.put({}); // Send message
      {}.get({}); // Receive message
      ]],
      {i(1, "mbox_name"), rep(1), rep(1), i(2, "message"), rep(1), i(3, "received_msg")}
    )
  ),

  -- Event declaration and usage
  s({trig="event", descr="Event declaration and usage"},
    fmt(
      [[
      event {};

      // Trigger event
      -> {};

      // Wait for event
      @({});
      ]],
      {i(1, "event_name"), rep(1), rep(1)}
    )
  ),

-- Covergroup
  s({trig="cg", descr="Covergroup declaration"},
    fmt(
      [[
      covergroup {} @({});
        {} : coverpoint {} {{
          bins {} = {{}};
        }}
      endgroup
      ]],
      {i(1, "cg_name"), i(2, "sampling_event"), i(3, "cp_name"), i(4, "variable"), i(5, "bins_name")}
    )
  ),
  -- Sequence declaration
  s({trig="seq", descr="Sequence declaration"},
    fmt(
      [[
      sequence {};
        {}
      endsequence
      ]],
      {i(1, "seq_name"), i(0)}
    )
  ),

  -- Property declaration
  s({trig="prop", descr="Property declaration"},
    fmt(
      [[
      property {};
        @({})
        {}
      endproperty
      ]],
      {i(1, "prop_name"), i(2, "clock_event"), i(0)}
    )
  ),

  -- Assertion directive
  s({trig="assert_prop", descr="Assertion directive"},
    fmt(
      [[
      {} prop_{}:
        assert property ({})
        else $error("{}: {}");
      ]],
      {c(1, {t(""), t("immediate ")}), i(2, "name"), i(3, "property"), i(4, "Error message"), i(0)}
    )
  ),

  -- Randomize with constraints
  s({trig="rand", descr="Randomize with constraints"},
    fmt(
      [[
      {} = new();
      if (!{}.randomize() with {{
        {}
      }}) $error("Randomization failed");
      ]],
      {i(1, "obj_name"), rep(1), i(0)}
    )
  ),

  -- Class declaration
  s({trig="class", descr="Class declaration"},
    fmt(
      [[
      class {} {};
        // Properties
        {}

        // Methods
        function new({});
          {}
        endfunction

        {}
      endclass
      ]],
      {i(1, "class_name"), c(2, {t(""), sn(nil, {t("extends "), i(1, "parent_class")})}), i(3), i(4), i(5), i(0)}
    )
  ),

  -- Interface declaration
  s({trig="intf", descr="Interface declaration"},
    fmt(
      [[
      interface {} {};
        // Signals
        {}

        // Modports
        modport {} (
          {}
        );

        // Tasks/Functions
        {}
      endinterface
      ]],
      {i(1, "intf_name"), c(2, {t(""), sn(nil, {t("("), i(1), t(")")})}), i(3), i(4, "modport_name"), i(5), i(0)}
    )
  ),

  -- Generate block
  s({trig="gen", descr="Generate block"},
    fmt(
      [[
      generate
        {}
      endgenerate
      ]],
      {i(0)}
    )
  ),

  -- Systemverilog Assertions
  s({trig="sva", descr="SystemVerilog Assertion"},
    fmt(
      [[
      {}assert_{}: assert {}({})
        {}
        else
          {}
      ]],
      {c(1, {t(""), t("property "), t("sequence ")}), i(2, "name"), rep(1), i(3, "condition"), 
       c(4, {t(""), sn(nil, {t("$info(\""), i(1, "Pass message"), t("\")")}) }), 
       c(5, {t("$error(\"Assertion failed\")"), sn(nil, {t("$error(\""), i(1, "Fail message"), t("\")")})})}
    )
  ),

  -- Clocking block
  s({trig="clock", descr="Clocking block"},
    fmt(
      [[
      clocking {} @({});
        default input #1step output #1ps;
        {}
      endclocking
      ]],
      {i(1, "cb_name"), i(2, "clock_event"), i(0)}
    )
  ),

  -- Program block
  s({trig="program", descr="Program block"},
    fmt(
      [[
      program {}({});
        {}
      endprogram
      ]],
      {i(1, "program_name"), i(2, "interface_instance"), i(0)}
    )
  ),
-- Foreach loop
  s({trig="foreach", descr="Foreach loop"},
    fmt(
      [[
      foreach ({} [{}]) begin
        {}
      end
      ]],
      {i(1, "item"), i(2, "array"), i(0)}
    )
  ),
s({trig="for", descr="For loop"},
  fmt(
    [[
    for (int {} = 0; {} < {}; {}++) begin
      {}
    end
    ]],
    {i(1, "i"), rep(1), i(2, "limit"), rep(1), i(0)}
  )
),
-- Display task
s({trig="disp", descr="Display task"},
  fmt(
    [[
    $display("{}", {});
    ]],
    {i(1, "format_string"), i(2, "arguments")}
  )
),

-- Strobe task
s({trig="strobe", descr="Strobe task"},
  fmt(
    [[
    $strobe("{}", {});
    ]],
    {i(1, "format_string"), i(2, "arguments")}
  )
),

-- Write task
s({trig="write", descr="Write task"},
  fmt(
    [[
    $write("{}", {});
    ]],
    {i(1, "format_string"), i(2, "arguments")}
  )
),

-- Monitor task
s({trig="monitor", descr="Monitor task"},
  fmt(
    [[
    $monitor("{}", {});
    ]],
    {i(1, "format_string"), i(2, "arguments")}
  )
),

-- Fwrite task
s({trig="fwrite", descr="Fwrite task"},
  fmt(
    [[
    $fwrite({}, "{}", {});
    ]],
    {i(1, "file_handle"), i(2, "format_string"), i(3, "arguments")}
  )
),

-- Sformat function
s({trig="sformat", descr="Sformat function"},
  fmt(
    [[
    $sformat({}, "{}", {});
    ]],
    {i(1, "string_var"), i(2, "format_string"), i(3, "arguments")}
  )
),

-- Timeformat task
s({trig="timeformat", descr="Timeformat task"},
  fmt(
    [[
    $timeformat({}, {}, "{}", {});
    ]],
    {i(1, "units"), i(2, "precision"), i(3, "suffix"), i(4, "min_field_width")}
  )
),

-- Printtimescale task
s({trig="ptscale", descr="Printtimescale task"},
  fmt(
    [[
    $printtimescale({});
    ]],
    {i(1, "module_or_scope")}
  )
),

-- Value change dump
s({trig="vcd", descr="Value change dump tasks"},
  fmt(
    [[
    $dumpfile("{}");
    $dumpvars({}, {});
    ]],
    {i(1, "filename.vcd"), i(2, "levels"), i(3, "module_or_variables")}
  )
),
s({trig="forever", descr="Forever loop"},
  fmt(
    [[
    forever begin
      {}
    end
    ]],
    {i(0)}
  )
),
s({trig="repeat", descr="Repeat loop"},
  fmt(
    [[
    repeat ({}) begin
      {}
    end
    ]],
    {i(1, "count"), i(0)}
  )
),
}


==================================================
File: snippets/sv/synthesizable.lua
==================================================

local ls = require("luasnip")
local s = ls.snippet
local t = ls.text_node
local i = ls.insert_node

return {
    -- Module
    s("mod", {
        t("module "), i(1, "module_name"),
        t({ " (", "\t" }), i(2),
        t({ "", ");", "" }),
        i(0),
        t({ "", "endmodule" })
    }),
    -- Always FF block
    s("aff", {
        t("always_ff @(posedge "), i(1, "clk"), t(") begin"),
        t({ "", "\t" }), i(0),
        t({ "", "end" })
    }),
    -- Always Comb block
    s("acomb", {
        t("always_comb begin"),
        t({ "", "\t" }), i(0),
        t({ "", "end" })
    }),
    -- Case statement
    s("case", {
        t("case ("), i(1, "expression"), t(")"),
        t({ "", "\t" }), i(2, "value"), t(": "), i(3),
        t({ "", "\tdefault: "}), i(0),
        t({ "", "endcase" })
    }),
    -- Generate for loop
    s("genfor", {
        t("generate"), t({ "", "for (int " }), i(1, "i"), t(" = 0; "), 
        i(2, "i"), t(" < "), i(3, "N"), t("; "), i(4, "i"), t("++) begin : "), i(5, "gen_label"),
        t({ "", "\t" }), i(0),
        t({ "", "end", "endgenerate" })
    }),
    s("if", {
        t("if ("), i(1, "condition"), t(") begin"),
        t({ "", "\t" }), i(2),
        t({ "", "end" }),
        i(0)
    }),
    
    s("ifel", {
        t("if ("), i(1, "condition"), t(") begin"),
        t({ "", "\t" }), i(2),
        t({ "", "end else begin" }),
        t({ "", "\t" }), i(3),
        t({ "", "end" }),
        i(0)
    }),
    
    s("while", {
        t("while ("), i(1, "condition"), t(") begin"),
        t({ "", "\t" }), i(0),
        t({ "", "end" })
    }),
    
    s("assign", {
        t("assign "), i(1, "signal"), t(" = "), i(2, "value"), t(";"),
        i(0)
    }),
}


==================================================
File: snippets/sv/uvm.lua
==================================================

local ls = require("luasnip")
local s = ls.snippet
local sn = ls.snippet_node
local t = ls.text_node
local i = ls.insert_node
local f = ls.function_node
local d = ls.dynamic_node
local c = ls.choice_node
local fmt = require("luasnip.extras.fmt").fmt
local fmta = require("luasnip.extras.fmt").fmta
local rep = require("luasnip.extras").rep
local helpers = require('personal.luasnip-helper-funcs')
return {
  -- UVM Component
  s({trig="uvc", descr="UVM Component"},
    fmt(
      [[
      class {} extends uvm_component;
        `uvm_component_utils({})

        function new(string name, uvm_component parent);
          super.new(name, parent);
        endfunction

        function void build_phase(uvm_phase phase);
          super.build_phase(phase);
          {}
        endfunction

        task run_phase(uvm_phase phase);
          super.run_phase(phase);
          {}
        endtask
      endclass
      ]],
      {i(1, "component_name"), rep(1), i(2), i(0)}
    )
  ),

  -- UVM Object
  s({trig="uvo", descr="UVM Object"},
    fmt(
      [[
      class {} extends uvm_object;
        `uvm_object_utils({})

        function new(string name = "");
          super.new(name);
        endfunction

        function void do_copy(uvm_object rhs);
          {} rhs_;
          super.do_copy(rhs);
          $cast(rhs_, rhs);
          {}
        endfunction
      endclass
      ]],
      {i(1, "object_name"), rep(1), rep(1), i(0)}
    )
  ),

  -- UVM Sequence
  s({trig="uvs", descr="UVM Sequence"},
    fmt(
      [[
      class {} extends uvm_sequence#({});
        `uvm_object_utils({})

        function new(string name = "");
          super.new(name);
        endfunction

        task body();
          {}
        endtask
      endclass
      ]],
      {i(1, "sequence_name"), i(2, "req_type"), rep(1), i(0)}
    )
  ),

  -- UVM Sequencer
  s({trig="uvsr", descr="UVM Sequencer"},
    fmt(
      [[
      class {} extends uvm_sequencer#({});
        `uvm_component_utils({})

        function new(string name, uvm_component parent);
          super.new(name, parent);
        endfunction
      endclass
      ]],
      {i(1, "sequencer_name"), i(2, "req_type"), rep(1)}
    )
  ),

  -- UVM Driver
  s({trig="uvd", descr="UVM Driver"},
    fmt(
      [[
      class {} extends uvm_driver#({});
        `uvm_component_utils({})

        function new(string name, uvm_component parent);
          super.new(name, parent);
        endfunction

        function void build_phase(uvm_phase phase);
          super.build_phase(phase);
          {}
        endfunction

        task run_phase(uvm_phase phase);
          super.run_phase(phase);
          forever begin
            seq_item_port.get_next_item(req);
            {}
            seq_item_port.item_done();
          end
        endtask
      endclass
      ]],
      {i(1, "driver_name"), i(2, "req_type"), rep(1), i(3), i(0)}
    )
  ),

  -- UVM Monitor
  s({trig="uvm", descr="UVM Monitor"},
    fmt(
      [[
      class {} extends uvm_monitor;
        `uvm_component_utils({})

        uvm_analysis_port#({}) ap;

        function new(string name, uvm_component parent);
          super.new(name, parent);
        endfunction

        function void build_phase(uvm_phase phase);
          super.build_phase(phase);
          ap = new("ap", this);
        endfunction

        task run_phase(uvm_phase phase);
          super.run_phase(phase);
          forever begin
            {}
          end
        endtask
      endclass
      ]],
      {i(1, "monitor_name"), rep(1), i(2, "item_type"), i(0)}
    )
  ),

  -- UVM Agent
  s({trig="uva", descr="UVM Agent"},
    fmt(
      [[
      class {} extends uvm_agent;
        `uvm_component_utils({})

        {} m_sequencer;
        {} m_driver;
        {} m_monitor;

        function new(string name, uvm_component parent);
          super.new(name, parent);
        endfunction

        function void build_phase(uvm_phase phase);
          super.build_phase(phase);
          if(get_is_active() == UVM_ACTIVE) begin
            m_sequencer = {}.type_id::create("m_sequencer", this);
            m_driver = {}.type_id::create("m_driver", this);
          end
          m_monitor = {}.type_id::create("m_monitor", this);
        endfunction

        function void connect_phase(uvm_phase phase);
          if(get_is_active() == UVM_ACTIVE) begin
            m_driver.seq_item_port.connect(m_sequencer.seq_item_export);
          end
        endfunction
      endclass
      ]],
      {i(1, "agent_name"), rep(1), i(2, "sequencer_type"), i(3, "driver_type"), i(4, "monitor_type"), rep(2), rep(3), rep(4)}
    )
  ),

  -- UVM Scoreboard
  s({trig="uvsc", descr="UVM Scoreboard"},
    fmt(
      [[
      class {} extends uvm_scoreboard;
        `uvm_component_utils({})

        uvm_analysis_export#({}) sb_export;
        uvm_tlm_analysis_fifo#({}) sb_fifo;

        function new(string name, uvm_component parent);
          super.new(name, parent);
        endfunction

        function void build_phase(uvm_phase phase);
          super.build_phase(phase);
          sb_export = new("sb_export", this);
          sb_fifo = new("sb_fifo", this);
        endfunction

        function void connect_phase(uvm_phase phase);
          sb_export.connect(sb_fifo.analysis_export);
        endfunction

        task run_phase(uvm_phase phase);
          {} item;
          forever begin
            sb_fifo.get(item);
            {}
          end
        endtask
      endclass
      ]],
      {i(1, "scoreboard_name"), rep(1), i(2, "item_type"), rep(2), rep(2), i(0)}
    )
  ),

  -- UVM Environment
  s({trig="uve", descr="UVM Environment"},
    fmt(
      [[
      class {} extends uvm_env;
        `uvm_component_utils({})

        {} m_agent;
        {} m_scoreboard;

        function new(string name, uvm_component parent);
          super.new(name, parent);
        endfunction

        function void build_phase(uvm_phase phase);
          super.build_phase(phase);
          m_agent = {}.type_id::create("m_agent", this);
          m_scoreboard = {}.type_id::create("m_scoreboard", this);
        endfunction

        function void connect_phase(uvm_phase phase);
          m_agent.m_monitor.ap.connect(m_scoreboard.sb_export);
        endfunction
      endclass
      ]],
      {i(1, "env_name"), rep(1), i(2, "agent_type"), i(3, "scoreboard_type"), rep(2), rep(3)}
    )
  ),

  -- UVM Test
  s({trig="uvt", descr="UVM Test"},
    fmt(
      [[
      class {} extends uvm_test;
        `uvm_component_utils({})

        {} m_env;

        function new(string name = "{}", uvm_component parent = null);
          super.new(name, parent);
        endfunction

        function void build_phase(uvm_phase phase);
          super.build_phase(phase);
          m_env = {}.type_id::create("m_env", this);
        endfunction

        task run_phase(uvm_phase phase);
          {}
        endtask
      endclass
      ]],
      {i(1, "test_name"), rep(1), i(2, "env_type"), rep(1), rep(2), i(0)}
    )
  ),

  -- UVM Factory Override
  s({trig="uvfo", descr="UVM Factory Override"},
    fmt(
      [[
      function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        set_type_override_by_type({}.get_type(), {}.get_type());
      endfunction
      ]],
      {i(1, "original_type"), i(2, "override_type")}
    )
  ),

  -- UVM Config DB Set
  s({trig="uvcds", descr="UVM Config DB Set"},
    fmt(
      [[
      uvm_config_db#({})::set(this, "{}", "{}", {});
      ]],
      {i(1, "type"), i(2, "instance_path"), i(3, "field_name"), i(4, "value")}
    )
  ),

  -- UVM Config DB Get
  s({trig="uvcdg", descr="UVM Config DB Get"},
    fmt(
      [[
      if (!uvm_config_db#({})::get(this, "", "{}", {}))
        `uvm_fatal("CONFIG_DB_ERROR", "{} not found in config DB")
      ]],
      {i(1, "type"), i(2, "field_name"), i(3, "variable"), rep(2)}
    )
  ),

  -- UVM Report Server
  s({trig="uvrs", descr="UVM Report Server"},
    fmt(
      [[
      uvm_report_server server;
      server = uvm_report_server::get_server();
      server.set_max_quit_count({});
      ]],
      {i(1, "max_quit_count")}
    )
  ),

  -- UVM Callback
  s({trig="uvcl", descr="UVM Callback"},
    fmt(
      [[
      class {} extends uvm_callback;
        `uvm_object_utils({})

        function new(string name = "{}");
          super.new(name);
        endfunction

        virtual task {}_cb({} context);
          {}
        endtask
      endclass
      ]],
      {i(1, "callback_name"), rep(1), rep(1), i(2, "callback_method"), i(3, "context_type"), i(0)}
    )
  ),

  -- UVM Resource DB Set
  s({trig="uvrds", descr="UVM Resource DB Set"},
    fmt(
      [[
      uvm_resource_db#({})::set("{}", "{}", {});
      ]],
      {i(1, "type"), i(2, "scope"), i(3, "name"), i(4, "value")}
    )
  ),

  -- UVM Resource DB Get
  s({trig="uvrdg", descr="UVM Resource DB Get"},
    fmt(
      [[
      if (!uvm_resource_db#({})::read_by_name("{}", "{}", {}))
        `uvm_fatal("RESOURCE_DB_ERROR", "{} not found in resource DB")
      ]],
      {i(1, "type"), i(2, "scope"), i(3, "name"), i(4, "variable"), rep(3)}
    )
  ),

  -- UVM Sequence Item
  s({trig="uvsi", descr="UVM Sequence Item"},
    fmt(
      [[
      class {} extends uvm_sequence_item;
        `uvm_object_utils({})

        {} {}; // Add your transaction fields here

        function new(string name = "{}");
          super.new(name);
        endfunction

        function void do_copy(uvm_object rhs);
          {} rhs_;
          super.do_copy(rhs);
          $cast(rhs_, rhs);
          {} = rhs_.{};
        endfunction

        function bit do_compare(uvm_object rhs, uvm_comparer comparer);
          {} rhs_;
          bit status = super.do_compare(rhs, comparer);
          $cast(rhs_, rhs);
          status &= comparer.compare_field("{}", {}, rhs_.{});
          return status;
        endfunction

        function string convert2string();
          string s;
          $sformat(s, "%s: {} = %0d", super.convert2string(), {});
          return s;
        endfunction
      endclass
      ]],
      {i(1, "item_name"), rep(1), i(2, "field_type"), i(3, "field_name"), rep(1), rep(1), rep(3), rep(3), rep(1), rep(3), rep(3), rep(3), rep(3), rep(3)}
    )
  ),
  s({trig="uvim", descr="Import UVM Package"},
    fmt(
      [[
      import uvm_pkg::*;
      `include "uvm_macros.svh"
      ]],
      {}
    )
  ),
  s({trig="uvou", descr="UVM Object Utils Block"},
    fmt(
      [[
      `uvm_object_utils_begin({})
        `uvm_field_{}({}, {})
      `uvm_object_utils_end
      ]],
      {
        i(1, "class_name"),
        i(2, "type"),
        i(3, "field_name"),
        i(4, "flags")
      }
    )
  ),
  s({trig="uvminfo", descr="UVM Info Message"},
    fmt(
      [[
      `uvm_info({}, $sformatf("{}"), UVM_{})]],
      {i(1,"get_type_name()"),i(2, "message"), c(3, {t("NONE"), t("LOW"), t("MEDIUM"), t("HIGH"), t("FULL")})}
    )
  ),
}



==================================================
File: snippets/sv/.jukit/.jukit_info.json
==================================================

{"terminal": "nvimterm"}