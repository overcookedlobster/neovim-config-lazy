# Chapter Checklist : Computer Systems A Programmerâ€™s Perspective

Page Offset: -6

- [x] **Chapter 1: A Tour of Computer Systems** (Page 37)
  - [x] 1.1 Information Is Bits + Context (Page 39)
  - [x] 1.2 Programs Are Translated by Other Programs into Different Forms (Page 40)
  - [x] 1.3 It Pays to Understand How Compilation Systems Work (Page 42)
  - [ ] 1.4 Processors Read and Interpret Instructions Stored in Memory (Page 43)
  - [ ] 1.5 Caches Matter (Page 47)
  - [ ] 1.6 Storage Devices Form a Hierarchy (Page 50)
  - [ ] 1.7 The Operating System Manages the Hardware (Page 50)
  - [ ] 1.8 Systems Communicate with Other Systems Using Networks (Page 55)
  - [ ] 1.9 Important Themes (Page 58)
  - [ ] 1.10 Summary (Page 63)

- [ ] **Chapter 2: Representing and Manipulating Information** (Page 67)
  - [ ] 2.1 Information Storage (Page 70)
  - [ ] 2.2 Integer Representations (Page 95)
  - [ ] 2.3 Integer Arithmetic (Page 120)
  - [ ] 2.4 Floating Point (Page 144)
  - [ ] 2.5 Summary (Page 162)

- [ ] **Chapter 3: Machine-Level Representation of Programs** (Page 199)
  - [ ] 3.1 A Historical Perspective (Page 202)
  - [ ] 3.2 Program Encodings (Page 205)
  - [ ] 3.3 Data Formats (Page 213)
  - [ ] 3.4 Accessing Information (Page 215)
  - [ ] 3.5 Arithmetic and Logical Operations (Page 227)
  - [ ] 3.6 Control (Page 236)
  - [ ] 3.7 Procedures (Page 274)
  - [ ] 3.8 Array Allocation and Access (Page 291)
  - [ ] 3.9 Heterogeneous Data Structures (Page 301)
  - [ ] 3.10 Combining Control and Data in Machine-Level Programs (Page 312)
  - [ ] 3.11 Floating-Point Code (Page 329)
  - [ ] 3.12 Summary (Page 345)

- [ ] **Chapter 4: Processor Architecture** (Page 387)
  - [ ] 4.1 The Y86-64 Instruction Set Architecture (Page 391)
  - [ ] 4.2 Logic Design and the Hardware Control Language HCL (Page 408)
  - [ ] 4.3 Sequential Y86-64 Implementations (Page 420)
  - [ ] 4.4 General Principles of Pipelining (Page 448)
  - [ ] 4.5 Pipelined Y86-64 Implementations (Page 457)
  - [ ] 4.6 Summary (Page 506)

- [ ] **Chapter 5: Optimizing Program Performance** (Page 531)
  - [ ] 5.1 Capabilities and Limitations of Optimizing Compilers (Page 534)
  - [ ] 5.2 Expressing Program Performance (Page 538)
  - [ ] 5.3 Program Example (Page 540)
  - [ ] 5.4 Eliminating Loop Inefficiencies (Page 544)
  - [ ] 5.5 Reducing Procedure Calls (Page 548)
  - [ ] 5.6 Eliminating Unneeded Memory References (Page 550)
  - [ ] 5.7 Understanding Modern Processors (Page 553)
  - [ ] 5.8 Loop Unrolling (Page 567)
  - [ ] 5.9 Enhancing Parallelism (Page 572)
  - [ ] 5.10 Summary (Page 583)

- [ ] **Chapter 6: The Memory Hierarchy** (Page 615)
  - [ ] 6.1 Storage Technologies (Page 617)
  - [ ] 6.2 Locality (Page 640)
  - [ ] 6.3 The Memory Hierarchy (Page 645)
  - [ ] 6.4 Cache Memories (Page 650)
  - [ ] 6.5 Writing Cache-Friendly Code (Page 669)
  - [ ] 6.6 Putting It Together: The Impact of Caches on Program Performance (Page 675)
  - [ ] 6.7 Summary (Page 684)

- [ ] **Chapter 7: Linking** (Page 705)
  - [ ] 7.1 Compiler Drivers (Page 707)
  - [ ] 7.2 Static Linking (Page 708)
  - [ ] 7.3 Object Files (Page 709)
  - [ ] 7.4 Relocatable Object Files (Page 710)
  - [ ] 7.5 Symbols and Symbol Tables (Page 711)
  - [ ] 7.6 Symbol Resolution (Page 715)
  - [ ] 7.7 Relocation (Page 725)
  - [ ] 7.8 Executable Object Files (Page 731)
  - [ ] 7.9 Loading Executable Object Files (Page 733)
  - [ ] 7.10 Dynamic Linking with Shared Libraries (Page 734)
  - [ ] 7.11 Loading and Linking Shared Libraries from Applications (Page 737)
  - [ ] 7.12 Position-Independent Code (PIC) (Page 740)
  - [ ] 7.13 Library Interpositioning (Page 743)
  - [ ] 7.14 Tools for Manipulating Object Files (Page 749)
  - [ ] 7.15 Summary (Page 749)

- [ ] **Chapter 8: Exceptional Control Flow** (Page 757)
  - [ ] 8.1 Exceptions (Page 759)
  - [ ] 8.2 Processes (Page 768)
  - [ ] 8.3 System Call Error Handling (Page 773)
  - [ ] 8.4 Process Control (Page 774)
  - [ ] 8.5 Signals (Page 792)
  - [ ] 8.6 Nonlocal Jumps (Page 817)
  - [ ] 8.7 Tools for Manipulating Processes (Page 822)
  - [ ] 8.8 Summary (Page 823)

- [ ] **Chapter 9: Virtual Memory** (Page 837)
  - [ ] 9.1 Physical and Virtual Addressing (Page 839)
  - [ ] 9.2 Address Spaces (Page 840)
  - [ ] 9.3 VM as a Tool for Caching (Page 841)
  - [ ] 9.4 VM as a Tool for Memory Management (Page 847)
  - [ ] 9.5 VM as a Tool for Memory Protection (Page 848)
  - [ ] 9.6 Address Translation (Page 849)
  - [ ] 9.7 Case Study: The Intel Core i7/Linux Memory System (Page 861)
  - [ ] 9.8 Memory Mapping (Page 869)
  - [ ] 9.9 Dynamic Memory Allocation (Page 875)
  - [ ] 9.10 Garbage Collection (Page 901)
  - [ ] 9.11 Common Memory-Related Bugs in C Programs (Page 906)
  - [ ] 9.12 Summary (Page 911)

- [ ] **Chapter 10: System-Level I/O** (Page 925)
  - [ ] 10.1 Unix I/O (Page 926)
  - [ ] 10.2 Files (Page 927)
  - [ ] 10.3 Opening and Closing Files (Page 929)
  - [ ] 10.4 Reading and Writing Files (Page 931)
  - [ ] 10.5 Robust Reading and Writing with the Rio Package (Page 933)
  - [ ] 10.6 Reading File Metadata (Page 939)
  - [ ] 10.7 Reading Directory Contents (Page 941)
  - [ ] 10.8 Sharing Files (Page 942)
  - [ ] 10.9 I/O Redirection (Page 945)
  - [ ] 10.10 Standard I/O (Page 947)
  - [ ] 10.11 Putting It Together: Which I/O Functions Should I Use? (Page 947)
  - [ ] 10.12 Summary (Page 949)

- [ ] **Chapter 11: Network Programming** (Page 953)
  - [ ] 11.1 The Client-Server Programming Model (Page 954)
  - [ ] 11.2 Networks (Page 955)
  - [ ] 11.3 The Global IP Internet (Page 960)
  - [ ] 11.4 The Sockets Interface (Page 968)
  - [ ] 11.5 Web Servers (Page 984)
  - [ ] 11.6 Putting It Together: The Tiny Web Server (Page 992)
  - [ ] 11.7 Summary (Page 1000)

- [ ] **Chapter 12: Concurrent Programming** (Page 1007)
  - [ ] 12.1 Concurrent Programming with Processes (Page 1009)
  - [ ] 12.2 Concurrent Programming with I/O Multiplexing (Page 1013)
  - [ ] 12.3 Concurrent Programming with Threads (Page 1021)
  - [ ] 12.4 Shared Variables in Threaded Programs (Page 1028)
  - [ ] 12.5 Synchronizing Threads with Semaphores (Page 1031)
  - [ ] 12.6 Using Threads for Parallelism (Page 1049)
  - [ ] 12.7 Other Concurrency Issues (Page 1056)
  - [ ] 12.8 Summary (Page 1066)
